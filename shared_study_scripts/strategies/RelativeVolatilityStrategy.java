package com.motivewave.platform.study.strategies;import com.motivewave.platform.sdk.common.DataSeries;import com.motivewave.platform.sdk.common.Instrument;import com.motivewave.platform.sdk.order_mgmt.OrderContext;import com.motivewave.platform.sdk.study.StudyHeader;import com.motivewave.platform.study.general.RelativeVolatilityIndex;/** Relative Volatility Index Strategy 120 */@StudyHeader(  namespace="com.motivewave",  id="ID_RVIST",  rb="com.motivewave.platform.study.nls.strings2",  name="NAME_RELATIVE_VOLATILITY_INDEX_STRATEGY",  label="LBL_RVIST",  desc="DESC_RVI",  menu="MENU_GENERAL",  helpLink="http://www.motivewave.com/strategies/relative_volatility_index_strategy.htm",  overlay=false,  signals=true,  strategy=true,  autoEntry=true,  manualEntry=false,  supportsUnrealizedPL=true,  supportsRealizedPL=true,  supportsTotalPL=true,  supportsPositionType=true)public class RelativeVolatilityStrategy extends RelativeVolatilityIndex{  @Override  public void onActivate(OrderContext ctx)  {    if (getSettings().isEnterOnActivate()) {      DataSeries series=ctx.getDataContext().getDataSeries();      int ind=series.isLastBarComplete() ? series.size() - 1 : series.size() - 2;      Boolean buy=series.getBoolean(ind, Signals.BUY);      Boolean sell=series.getBoolean(ind, Signals.SELL);      if (buy == null || sell == null) return;      int tradeLots=getSettings().getTradeLots();      float qty=tradeLots*=ctx.getInstrument().getDefaultQuantityAsFloat();      switch (getSettings().getPositionType()) {      case LONG: // Only Long Positions are allowed.        if (buy) ctx.buy(qty);        break;      case SHORT: // Only Short Positions are allowed.        if (sell) ctx.sell(qty);        break;      default: // Both Long and Short Positions Allowed        if (buy) ctx.buy(qty);        else ctx.sell(qty);      }    }  }  @Override  public void onSignal(OrderContext ctx, Object signal)  {    Instrument instr=ctx.getInstrument();    float position=ctx.getPositionAsFloat();    float qty=(getSettings().getTradeLots() * instr.getDefaultQuantityAsFloat());    switch (getSettings().getPositionType()) {    case LONG: // Only Long Positions are allowed.      if (position == 0 && signal == Signals.BUY) {        ctx.buy(qty); // Open Long Position      }      if (position > 0 && signal == Signals.SELL) {        ctx.sell(qty); // Close Long Position      }      break;    case SHORT: // Only Short Positions are allowed.      if (position == 0 && signal == Signals.SELL) {        ctx.sell(qty); // Open Short Position      }      if (position < 0 && signal == Signals.BUY) {        ctx.buy(qty); // Close Short Position      }      break;    default: // Both Long and Short Positions Allowed      // qty += Math.abs(position); // Stop and Reverse if there is an open position      // allow for 2 successive transactions      if (position <= 0 && signal == Signals.BUY) {        ctx.buy(qty); // Open Long Position      }      if (position >= 0 && signal == Signals.SELL) {        ctx.sell(qty); // Open Short Position      }    }  }}