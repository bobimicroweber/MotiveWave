package com.motivewave.platform.study.general;import java.util.ArrayList;import com.motivewave.platform.sdk.common.BarSize;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.DataSeries;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Enums.BarSizeType;import com.motivewave.platform.sdk.common.Inputs;import com.motivewave.platform.sdk.common.NVP;import com.motivewave.platform.sdk.common.Util;import com.motivewave.platform.sdk.common.desc.BarSizeDescriptor;import com.motivewave.platform.sdk.common.desc.DiscreteDescriptor;import com.motivewave.platform.sdk.common.desc.IndicatorDescriptor;import com.motivewave.platform.sdk.common.desc.IntegerDescriptor;import com.motivewave.platform.sdk.common.desc.PathDescriptor;import com.motivewave.platform.sdk.common.desc.SliderDescriptor;import com.motivewave.platform.sdk.common.desc.ValueDescriptor;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;@StudyHeader(  namespace="com.motivewave",  id="ID_HV",  rb="com.motivewave.platform.study.nls.strings",  label="LBL_HV",  name="NAME_HISTORICAL_VOLATILITY",  desc="DESC_HV",  helpLink="http://www.motivewave.com/studies/historical_volatility.htm",  signals=false,  overlay=false)public class HistoricalVolatility extends Study{  enum Values { HV, PERCENT_MOVE };  final String CLOSE = "CLOSE";  final String CLOSE_LN = "CLOSE_LN";  final String HIGH_LOW = "HIGH_LOW";  final String TRUE_RANGE = "TRUE_RANGE";    @Override  public void initialize(Defaults defaults)  {    var sd=createSD();    var tab=sd.addTab(get("TAB_GENERAL"));    // This invisible setting is used hard code a barsize of 1 day    // Historical volatility is always calculated on daily bars    sd.addInvisibleSetting(new BarSizeDescriptor(Inputs.BARSIZE, get("LBL_TIMEFRAME"), BarSize.getBarSize(BarSizeType.LINEAR, 1440)));        var inputs=tab.addGroup(get("LBL_INPUTS"));    var types = new ArrayList<NVP>();    types.add(new NVP(get("LBL_CLOSE_TO_CLOSE"), CLOSE));    types.add(new NVP(get("LBL_CLOSE_TO_CLOSE_LN"), CLOSE_LN));    types.add(new NVP(get("LBL_HIGH_LOW_RANGE"), HIGH_LOW));    types.add(new NVP(get("LBL_TRUE_RANGE"), TRUE_RANGE));    inputs.addRow(new DiscreteDescriptor(Inputs.METHOD, get("LBL_METHOD"), CLOSE, types));        // Typical periods for Historical Volatility are 10, 20 and 3 day periods    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD, get("LBL_PERIOD"), 20, 1, 999, 1));    // For stocks, it is generally assumed that there are 254 trading days in a year.    // The user may want to adjust this for other instrument types.    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD2, get("LBL_ANNUAL"), 254, 1, 999, 1));    var settings=tab.addGroup(get("LBL_DISPLAY"));    var path = new PathDescriptor(Inputs.PATH, get("LBL_HV"), defaults.getLineColor(), 1.0f, null, true, false, true);    path.setShadeType(Enums.ShadeType.BELOW);    settings.addRow(path);    settings.addRow(new IndicatorDescriptor(Inputs.IND, get("LBL_INDICATOR"), null, null, false, true, true));    // Quick Settings (Tool Bar and Popup Editor)    sd.addQuickSettings(Inputs.METHOD);    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD, get("LBL_PERIOD"), 20, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD2, get("LBL_ANNUAL"), 254, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(Inputs.PATH);    var desc=createRD();    desc.setLabelSettings(Inputs.METHOD, Inputs.PERIOD, Inputs.PERIOD2);    desc.exportValue(new ValueDescriptor(Values.HV, get("LBL_HV"), new String[] { Inputs.METHOD, Inputs.PERIOD,  Inputs.PERIOD2 }));    desc.declarePath(Values.HV, Inputs.PATH);    desc.declareIndicator(Values.HV, Inputs.IND);        // Need to tell MotiveWave that the HV values are added to the data series defined by the Inputs.BARSIZE key (ie 1-day bars    desc.setValueSeries(Values.HV, Inputs.BARSIZE);    desc.setRangeKeys(Values.HV);    desc.setMinTick(0.0001);  }  @Override  public int getMinBars() { return getSettings().getInteger(Inputs.PERIOD, 20) + 1; }  // This method is overridden to calculate the values on the 1-day data series  // instead of the chart data series.  @Override  protected void calculateValues(DataContext ctx)  {    if (ctx == null) return;    var barSizes = getBarSizes();    if (!Util.isEmpty(barSizes)) {      for(BarSize bs : barSizes) {        DataSeries ds = ctx.getDataSeries(bs);        if (ds == null || !ds.hasData()) return;      }    }        // Bar Size should always be 1 day    var barSize = getSettings().getBarSize(Inputs.BARSIZE);    var series = ctx.getDataSeries(barSize);    if (series == null) return;    int period=getSettings().getInteger(Inputs.PERIOD);    int annual=getSettings().getInteger(Inputs.PERIOD2);    String method = getSettings().getString(Inputs.METHOD, CLOSE);    var header = getHeader();    boolean updates = getSettings().isBarUpdates() || (header != null && header.requiresBarUpdates());    for(int i = 1; i < series.size(); i++) {      if (series.isComplete(i)) continue;      if (!updates && !series.isBarComplete(i)) continue;      // This is percent move between the current and previous day.      // Currently we are using the closing price, but there are other methods      // that we may want to consider other methods like true range or high-low range      double percentMove = 0;      if (Util.compare(method, CLOSE)) {        float close=series.getClose(i);        float prevClose=series.getClose(i - 1);        percentMove = (close - prevClose)/prevClose;      }      else if (Util.compare(method, CLOSE_LN)) {        float close=series.getClose(i);        float prevClose=series.getClose(i - 1);        percentMove = Math.log(close/prevClose);      }      else if (Util.compare(method, HIGH_LOW)) {        float high=series.getHigh(i);        float low=series.getLow(i);        percentMove = high/low;      }      else if (Util.compare(method, TRUE_RANGE)) {        float prevClose=series.getClose(i - 1);        float high=Util.maxFloat(series.getHigh(i), prevClose);        float low=Util.minFloat(series.getLow(i), prevClose);        percentMove = high/low;      }      series.setDouble(i, Values.PERCENT_MOVE, percentMove);      if (i < period + 1) continue;      double hv=100 * series.std(i, period, Values.PERCENT_MOVE) * Math.sqrt(annual);      series.setDouble(i, Values.HV, hv);      series.setComplete(i, series.isBarComplete(i));    }  }}