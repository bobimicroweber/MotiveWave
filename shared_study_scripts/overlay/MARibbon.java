package com.motivewave.platform.study.overlay;import java.util.ArrayList;import java.util.List;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Inputs;import com.motivewave.platform.sdk.common.desc.IndicatorDescriptor;import com.motivewave.platform.sdk.common.desc.InputDescriptor;import com.motivewave.platform.sdk.common.desc.IntegerDescriptor;import com.motivewave.platform.sdk.common.desc.MAMethodDescriptor;import com.motivewave.platform.sdk.common.desc.PathDescriptor;import com.motivewave.platform.sdk.common.desc.SliderDescriptor;import com.motivewave.platform.sdk.common.desc.ValueDescriptor;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;/** Moving Average Ribbon.  This is similar to the Rainbow study, but allows the user to choose how many    moving averages to include. */@StudyHeader(  namespace="com.motivewave",  id="ID_MA_RIBBON",  rb="com.motivewave.platform.study.nls.strings",  name="NAME_MA_RIBBON",  label="LBL_MA_RIBBON",  desc="DESC_MA_RIBBON",  menu="MENU_MOVING_AVERAGE",  requiresVolume=false,  signals=false,  overlay=true,  studyOverlay=true)public class MARibbon extends Study{  final static String STEP="step", COUNT="count";  @Override  public void initialize(Defaults defaults)  {    var sd=createSD();    var tab=sd.addTab(get("TAB_GENERAL"));    var inputs=tab.addGroup(get("LBL_INPUTS"));    inputs.addRow(new InputDescriptor(Inputs.INPUT, get("LBL_INPUT"), Enums.BarInput.CLOSE));    inputs.addRow(new MAMethodDescriptor(Inputs.METHOD, get("LBL_METHOD"), Enums.MAMethod.SMA));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD, get("LBL_PERIOD"), 2, 1, 999, 1));    inputs.addRow(new IntegerDescriptor(STEP, get("LBL_STEP"), 2, 1, 99, 1));    inputs.addRow(new IntegerDescriptor(COUNT, get("LBL_MA_COUNT"), 6, 1, 99, 1));    var settings=tab.addGroup(get("LBL_PATHS"));    settings.addRow(new PathDescriptor(Inputs.PATH, get("LBL_PRIMARY_MA"), defaults.getBlue(), 1.0f, null, true, true, true));    settings.addRow(new PathDescriptor(Inputs.PATH2, get("LBL_OTHER_MAS"), defaults.getLineColor(), 1.0f, null, true, true, true));    settings=tab.addGroup(get("LBL_INDICATORS"));    settings.addRow(new IndicatorDescriptor(Inputs.IND, get("LBL_PRIMARY_MA"), defaults.getBlue(), null, false, true, true));        // Quick Settings (Tool Bar and Popup Editor)    sd.addQuickSettings(Inputs.INPUT, Inputs.METHOD);    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD, get("LBL_PERIOD"), 2, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(STEP, COUNT, Inputs.PATH, Inputs.PATH2);    var desc=createRD();    desc.setLabelSettings(Inputs.METHOD, Inputs.PERIOD, "step", "count");    desc.declareIndicator("ma1", Inputs.IND);  }  @Override  public void onLoad(Defaults defaults) { updateDescriptor(); }  @Override  public void onSettingsUpdated(DataContext ctx)  {    updateDescriptor();    super.onSettingsUpdated(ctx);  }    private void updateDescriptor()  {    int period= getSettings().getInteger(Inputs.PERIOD);    int count = getSettings().getInteger(COUNT, 2);    int step = getSettings().getInteger(STEP, 2);    var method=getSettings().getMAMethod(Inputs.METHOD);        var desc = getRuntimeDescriptor();    desc.getDefaultPlot().clearPaths();    desc.getDefaultPlot().clearIndicators();    desc.exportValue(new ValueDescriptor("ma1", get("LBL_PRIMARY_MA"), new String[] { Inputs.METHOD, Inputs.PERIOD }));    desc.declarePath("ma1", Inputs.PATH);    List<String> keys = new ArrayList<>();    keys.add("ma1");    for(int i = 2; i <= count; i++) {      period += step;      keys.add("ma" + i);      desc.declarePath("ma" + i, Inputs.PATH2);      desc.exportValue(new ValueDescriptor("ma" + i, get("LBL_RIBBON_MA", method, period), null));    }        setMinBars(period*2);    desc.setRangeKeys(keys.toArray());  }  @Override  protected void calculate(int index, DataContext ctx)  {    var method=getSettings().getMAMethod(Inputs.METHOD);    Object input=getSettings().getInput(Inputs.INPUT, Enums.BarInput.CLOSE);    int period=getSettings().getInteger(Inputs.PERIOD);    if (index < period) return;    var series=ctx.getDataSeries();    Double ma=series.ma(method, index, period, input);    series.setDouble(index, "ma1", ma);        int step = getSettings().getInteger("step", 2);    int count = getSettings().getInteger("count", 2);    for(int i = 2; i <= count; i++) {      period += step;      ma=series.ma(method, index, period, input);      if (ma == null) return; // not enough data      series.setDouble(index, "ma" + i, ma);    }    series.setComplete(index, series.isBarComplete(index));  }}