package com.motivewave.platform.study.general3;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Enums.ColorPolicy;import com.motivewave.platform.sdk.common.Inputs;import com.motivewave.platform.sdk.common.X11Colors;import com.motivewave.platform.sdk.common.desc.GuideDescriptor;import com.motivewave.platform.sdk.common.desc.IndicatorDescriptor;import com.motivewave.platform.sdk.common.desc.InputDescriptor;import com.motivewave.platform.sdk.common.desc.IntegerDescriptor;import com.motivewave.platform.sdk.common.desc.MAMethodDescriptor;import com.motivewave.platform.sdk.common.desc.PathDescriptor;import com.motivewave.platform.sdk.common.desc.SliderDescriptor;import com.motivewave.platform.sdk.common.desc.ValueDescriptor;import com.motivewave.platform.sdk.study.Plot;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;/** Directional Movement Stochastic 193 */@StudyHeader(    namespace="com.motivewave",     id="DMI_STOCHASTIC",     rb="com.motivewave.platform.study.nls.strings2",    name="NAME_DMI_STOCHASTIC",     desc="DESC_DMI_STOCH",    label="LBL_DMIST",    helpLink="http://www.motivewave.com/studies/dmi_stochastic.htm",    overlay=false,    studyOverlay=true)public class DMIStochastic extends Study{  // Settings  final static String PERIOD5 = "Period5";  final static String DMI_OSC_PATH = "dmiOscPath", DMI_OSC_IND = "dmiOscInd", DMI_STOCH_PATH = "dmiStochPath", DMI_STOCH_IND = "dmiStochInd";  final static String MA_PATH = "maPath", MA_IND = "maInd";  final static String DMI_STOCH_TOP_GUIDE = "dmiStochTopG", DMI_STOCH_MID_GUIDE = "dmiStochMidG", DMI_STOCH_BOTT_GUIDE = "dmiStochBottG";  static final String UP_COLOR="upColor", DOWN_COLOR="downColor";  static final String DMI_STOCH_PLOT="dmiStochPlot";   enum Values { DMI_OSC, FAST_K, SLOW_K, DMI_STOCH, MA, PDM, NDM, DX, PDI, NDI, TR }  //enum Signals { BUY, SELL }  @Override  public void initialize(Defaults defaults)  {    var sd = createSD();    var tab = sd.addTab(get("TAB_SETTINGS"));        var inputs = tab.addGroup("");    inputs.addRow(new InputDescriptor(Inputs.INPUT, get("INPUT"), Enums.BarInput.CLOSE));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD, get("DMI_PERIOD"), 10, 1, 9999, 1));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD2, get("FAST_K_PERIOD"), 10, 1, 9999, 1));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD3, get("SLOW_K_PERIOD"), 3, 1, 9999, 1));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD4, get("SMOOTH_PERIOD"), 3, 1, 9999, 1));    inputs.addRow(new MAMethodDescriptor(Inputs.METHOD, get("STOCHASTIC_METHOD"), Enums.MAMethod.SMA));       inputs.addRow(new IntegerDescriptor(PERIOD5, get("MA_PERIOD"), 50, 1, 9999, 1));    inputs.addRow(new MAMethodDescriptor(Inputs.METHOD2, get("MA_METHOD"), Enums.MAMethod.SMA));    tab = sd.addTab(get("TAB_DISPLAY"));    var colors = tab.addGroup("");    var bars = new PathDescriptor(Inputs.BARS, get("DMI_OSCILLATOR_PATH"), defaults.getBlue(), 1.0f, null, true, true, true);    bars.setShowAsBars(true);    bars.setSupportsShowAsBars(true);    bars.setColor2(defaults.getRed());    bars.setColorPolicy(ColorPolicy.POSITIVE_NEGATIVE);        colors.addRow(bars);    colors.addRow(new IndicatorDescriptor(DMI_OSC_IND, get("DMI_OSCILLATOR_INDICATOR"), defaults.getBlue(), X11Colors.WHITE, false, true, true));    colors.addRow(new PathDescriptor(DMI_STOCH_PATH, get("DMI_STOCHASTIC_PATH"), defaults.getBlue(), 1.0f, null, true, true, true));    colors.addRow(new IndicatorDescriptor(DMI_STOCH_IND, get("DMI_STOCHASTIC_INDICATOR"), defaults.getBlue(), X11Colors.WHITE, false, true, true));        colors.addRow(new PathDescriptor(MA_PATH, get("MA_PATH"), defaults.getBlue(), 1.0f, null, true, true, true));    colors.addRow(new IndicatorDescriptor(MA_IND, get("MA_INDICATOR"), defaults.getBlue(), X11Colors.WHITE, false, true, true));     tab = sd.addTab(get("GUIDES"));    var guides=tab.addGroup(get("DMI_OSCILLATOR_GUIDES"));    var topDesc=new GuideDescriptor(Inputs.TOP_GUIDE, get("TOP_GUIDE"), 20, 0, 999, 1, true);    topDesc.setLineColor(defaults.getRed());    guides.addRow(topDesc);    var mg=new GuideDescriptor(Inputs.MIDDLE_GUIDE, get("MIDDLE_GUIDE"), 0, -999, 999, 1, true);    mg.setDash(new float[] { 3, 3 });    guides.addRow(mg);    var bottomDesc=new GuideDescriptor(Inputs.BOTTOM_GUIDE, get("BOTTOM_GUIDE"), -20, -999, 0, 1, true);    bottomDesc.setLineColor(defaults.getGreen());    guides.addRow(bottomDesc);    var guides2=tab.addGroup(get("DMI_STOCHASTIC_GUIDES"));    var topDesc2=new GuideDescriptor(DMI_STOCH_TOP_GUIDE, get("TOP_GUIDE"), 90, 0, 999.1, .1, true);    topDesc2.setLineColor(defaults.getRed());    guides2.addRow(topDesc2);    var mg2=new GuideDescriptor(DMI_STOCH_MID_GUIDE, get("MIDDLE_GUIDE"), 50, 0, 999.1, .1, true);    mg2.setDash(new float[] { 3, 3 });    guides2.addRow(mg2);    var bottomDesc2=new GuideDescriptor(DMI_STOCH_BOTT_GUIDE, get("BOTTOM_GUIDE"), 10, 0, 999.1, .1, true);    bottomDesc2.setLineColor(defaults.getGreen());    guides2.addRow(bottomDesc2);        // Quick Settings (Tool Bar and Popup Editor)    sd.addQuickSettings(Inputs.INPUT);    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD, get("DMI_PERIOD"), 10, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD2, get("DMI_STOCH_FAST_K_PERIOD"), 10, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD3, get("DMI_STOCH_SLOW_K_PERIOD"), 3, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD4, get("DMI_STOCH_SMOOTH_PERIOD"), 3, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(Inputs.METHOD);    sd.addQuickSettings(new SliderDescriptor(PERIOD5, get("MA_PERIOD"), 10, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(Inputs.METHOD2, DMI_OSC_PATH, DMI_STOCH_PATH, MA_PATH);    var desc = createRD();    desc.exportValue(new ValueDescriptor(Values.DMI_OSC, get("DMI_OSC"), new String[] {Inputs.INPUT,Inputs.PERIOD}));    desc.exportValue(new ValueDescriptor(Values.DMI_STOCH, get("DMI_STOCH"), new String[] {Inputs.PERIOD2, Inputs.PERIOD3, Inputs.PERIOD4, Inputs.METHOD}));    desc.exportValue(new ValueDescriptor(Values.MA, get("MA"), new String[] {PERIOD5, Inputs.METHOD2}));    // Price plot (ma)    desc.getPricePlot().setLabelSettings(Inputs.INPUT, PERIOD5);    desc.getPricePlot().setLabelPrefix(get("MA"));    desc.getPricePlot().declarePath(Values.MA, MA_PATH);    desc.getPricePlot().declareIndicator(Values.MA, MA_IND);    // Default Plot (DMI_OSC)    desc.setLabelSettings(Inputs.INPUT, Inputs.PERIOD);    desc.setLabelPrefix(get("DMI_OSC"));    desc.setTabName(get("DMI_OSC"));    desc.declarePath(Values.DMI_OSC, Inputs.BARS);    desc.declareIndicator(Values.DMI_OSC, DMI_OSC_IND);        desc.getDefaultPlot().declareGuide(Inputs.TOP_GUIDE);    desc.getDefaultPlot().declareGuide(Inputs.MIDDLE_GUIDE);    desc.getDefaultPlot().declareGuide(Inputs.BOTTOM_GUIDE);    desc.setRangeKeys(Values.DMI_OSC);    // DMI_STOCH Plot    var dsPlot = new Plot();    desc.addPlot(DMI_STOCH_PLOT, dsPlot);    dsPlot.setLabelSettings(Inputs.INPUT, Inputs.PERIOD2, Inputs.PERIOD3, Inputs.PERIOD4 );    dsPlot.setLabelPrefix(get("DMI_STOCH"));    dsPlot.setTabName(get("DMI_STOCH"));    dsPlot.declarePath(Values.DMI_STOCH, DMI_STOCH_PATH);    dsPlot.declareIndicator(Values.DMI_STOCH, DMI_STOCH_IND);    dsPlot.declareGuide(DMI_STOCH_TOP_GUIDE);    dsPlot.declareGuide(DMI_STOCH_MID_GUIDE);    dsPlot.declareGuide(DMI_STOCH_BOTT_GUIDE);    dsPlot.setRangeKeys(Values.DMI_STOCH);  }  @Override  public void onLoad(Defaults defaults)  {    int p1=getSettings().getInteger(Inputs.PERIOD);    int p2=getSettings().getInteger(Inputs.PERIOD2);    int p3=getSettings().getInteger(Inputs.PERIOD3);    int p4=getSettings().getInteger(Inputs.PERIOD4);    int p5=getSettings().getInteger(PERIOD5);         int maxPd = Math.max(Math.max(Math.max(Math.max(p1, p2), p3), p4), p5);        setMinBars(maxPd);  }    @Override  protected void calculate(int index, DataContext ctx)  {    int dmiPd = getSettings().getInteger(Inputs.PERIOD);    if (index < dmiPd) return;    int fastkPd = getSettings().getInteger(Inputs.PERIOD2);    int slowkPd = getSettings().getInteger(Inputs.PERIOD3);    int stochSmPd = getSettings().getInteger(Inputs.PERIOD4);    int maPd = getSettings().getInteger(PERIOD5);    int maxPd = Math.max(Math.max(Math.max(Math.max(dmiPd, fastkPd ), slowkPd), stochSmPd), maPd);    if (index < maxPd) return;        Object input = getSettings().getInput(Inputs.INPUT);    var stochMethod = getSettings().getMAMethod(Inputs.METHOD);    var maMethod = getSettings().getMAMethod(Inputs.METHOD2);    var series = ctx.getDataSeries();        // Calculate the +DM, -DM and TR    Float pDm = series.getPositiveDM(index);    Float nDm = series.getNegativeDM(index);    Float tr = series.getTrueRange(index);    if (pDm == null || nDm == null || tr ==null) return;        series.setFloat(index, Values.PDM, pDm);    series.setFloat(index, Values.NDM, nDm);    series.setFloat(index, Values.TR, tr);    // Calculate the Average +DM, -DM and TR    Double pdMa = series.smma(index, dmiPd, Values.PDM);    Double ndMa = series.smma(index, dmiPd, Values.NDM);    Double tra = series.smma(index, dmiPd, Values.TR);    if (pdMa == null || ndMa == null || tra == null) return;    // Determine the +DI, -DI and DX    double pdi = pdMa / tra * 100;    double ndi = ndMa / tra * 100;    // This appears to be backwards (according to several customers)    // originally this  was ndi - pdi, switching to pdi - ndi (tony)    //double dmiOsc = ndi - pdi;    double dmiOsc = pdi - ndi;    series.setDouble(index, Values.DMI_OSC, dmiOsc);    if (index < maxPd + fastkPd) return;        //DMI Stochastic    double lowest=series.lowest(index, fastkPd, Values.DMI_OSC);    double highest=series.highest(index, fastkPd, Values.DMI_OSC);    double fastK = (dmiOsc - lowest) / (highest - lowest) * 100.0;    series.setDouble(index, Values.FAST_K, fastK);    if (index < maxPd + fastkPd + slowkPd) return;        Double slowK=series.ma(stochMethod, index, slowkPd, Values.FAST_K);    if (slowK == null) return;    series.setDouble(index, Values.SLOW_K, slowK);    if (index < maxPd + fastkPd + slowkPd) return;       Double dmiStoch =series.ma(stochMethod, index, stochSmPd, Values.SLOW_K);    if (dmiStoch == null) return;    series.setDouble(index, Values.DMI_STOCH, dmiStoch);    // MA    Double ma = series.ma(maMethod, index, maPd, input);    if (ma == null) return;    series.setDouble(index, Values.MA, ma);            series.setComplete(index);  }}