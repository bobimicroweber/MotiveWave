package com.motivewave.platform.study.general3;import java.awt.Color;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Inputs;import com.motivewave.platform.sdk.common.LineInfo;import com.motivewave.platform.sdk.common.X11Colors;import com.motivewave.platform.sdk.common.desc.ColorDescriptor;import com.motivewave.platform.sdk.common.desc.DoubleDescriptor;import com.motivewave.platform.sdk.common.desc.GuideDescriptor;import com.motivewave.platform.sdk.common.desc.IndicatorDescriptor;import com.motivewave.platform.sdk.common.desc.InputDescriptor;import com.motivewave.platform.sdk.common.desc.IntegerDescriptor;import com.motivewave.platform.sdk.common.desc.MAMethodDescriptor;import com.motivewave.platform.sdk.common.desc.PathDescriptor;import com.motivewave.platform.sdk.common.desc.SliderDescriptor;import com.motivewave.platform.sdk.common.desc.ValueDescriptor;import com.motivewave.platform.sdk.study.Plot;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;import com.motivewave.platform.study.general.Utility;/** TMV Trend Momentum Volatility Volume 188 */@StudyHeader(    namespace="com.motivewave",     id="TREND_MOM_VOLT_VOL",     rb="com.motivewave.platform.study.nls.strings2",    name="NAME_TMV",     desc="DESC_TMV",    label="LBL_TMV",    helpLink="http://www.motivewave.com/studies/trend_momentum_volatility_volume.htm",    overlay=false,    studyOverlay=true)public class TMV extends Study{  // Settings  final static String K_PERIOD = "kPeriod";  final static String VF_PERIOD = "vfPeriod";  final static String VS_PERIOD = "vsPeriod";  final static String ADX_PERIOD = "adxPeriod";  final static String SMA_PERIOD = "smaPeriod";  final static String K_TOP_PATH = "kTopPath";  final static String K_MID_PATH = "kMidPath";  final static String K_BOTT_PATH = "kBottPath";  final static String K_TOP_IND = "kTopInd";  final static String K_MID_IND = "kMidInd";  final static String K_BOTT_IND = "kBottInd";  final static String K_UPPER = "kUpper";  final static String K_LOWER = "kLower";  final static String ADX_PATH = "adxPath";  final static String PDI_PATH = "pdiPath";  final static String NDI_PATH = "ndiPath";  final static String SMA_PATH = "smaPath";    final static String ADX_IND = "adxInd";  final static String PDI_IND = "pdiInd";  final static String NDI_IND = "ndiInd";  final static String SMA_IND = "smaInd";    final static String ADX_PLOT = "adxPlot";  final static String VO_PATH = "voPath";  final static String VO_IND = "voInd";  final static String VO_PLOT = "voPlot";  final static String ADX_TOP_GUIDE = "adxTopG";  final static String ADX_MID_GUIDE = "adxMidG";  final static String ADX_BOTT_GUIDE = "adxBottG";  static final String UP_COLOR="upColor";  static final String DOWN_COLOR="downColor";  static final String NEUTRAL_COLOR="neutralColor";   enum Values { CCI, TR, PDM, NDM, DX, PDI, NDI, ADX, SMA, VO, TOP, MIDDLE, BOTTOM }  enum Signals { BUY, SELL }  @Override  public void initialize(Defaults defaults)  {    var sd = createSD();    var tab = sd.addTab(get("TAB_GENERAL"));        var inputs = tab.addGroup(get("INPUTS"));    inputs.addRow(new InputDescriptor(Inputs.INPUT, get("INPUT"), Enums.BarInput.CLOSE));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD, get("CCI_PERIOD"), 13, 1, 9999, 1));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD2, get("KELTNER_PERIOD"), 13, 1, 9999, 1));    inputs.addRow(new DoubleDescriptor(K_UPPER, get("KELTNER_UPPER_RANGE"), 2.0, 0.1, 999, 0.1));    inputs.addRow(new DoubleDescriptor(K_LOWER, get("KELTNER_LOWER_RANGE"), 2.0, 0.1, 999, 0.1));    inputs.addRow(new MAMethodDescriptor(Inputs.METHOD, get("VOLUME_METHOD"), Enums.MAMethod.SMA));    inputs.addRow(new IntegerDescriptor(VF_PERIOD, get("VOLUME_FAST_PERIOD"), 1, 1, 9999, 1));    inputs.addRow(new IntegerDescriptor(VS_PERIOD, get("VOLUME_SLOW_PERIOD"), 20, 1, 9999, 1));    inputs.addRow(new IntegerDescriptor(ADX_PERIOD, get("ADX_PERIOD"), 10, 1, 9999, 1));    inputs.addRow(new IntegerDescriptor(SMA_PERIOD, get("SMA_PERIOD"), 8, 1, 9999, 1));    tab = sd.addTab(get("COLORS1"));    var colors = tab.addGroup(get("CCI_PATH_AND_INDICATOR"));    colors.addRow(new PathDescriptor(Inputs.PATH, get("CCI_PATH"), X11Colors.CADET_BLUE, 1.0f, null, true, true, true));    colors.addRow(new IndicatorDescriptor(Inputs.IND, get("CCI_INDICATOR"), X11Colors.CADET_BLUE, X11Colors.WHITE, false, true, true));        colors = tab.addGroup(get("KELTNER_PATHS_AND_INDICATORS"));    colors.addRow(new PathDescriptor(K_TOP_PATH, get("TOP_PATH"), X11Colors.CADET_BLUE, 1.0f, null, true, true, true));    colors.addRow(new PathDescriptor(K_MID_PATH, get("MIDDLE_PATH"), X11Colors.DARK_SLATE_GRAY, 1.0f, null, true, true, true));    colors.addRow(new PathDescriptor(K_BOTT_PATH, get("BOTTOM_PATH"), X11Colors.DARK_SLATE_GRAY, 1.0f, null, true, true, true));    colors.addRow(new IndicatorDescriptor(K_TOP_IND, get("TOP_INDICATOR"), X11Colors.CADET_BLUE, X11Colors.WHITE, false, true, true));    colors.addRow(new IndicatorDescriptor(K_MID_IND, get("MIDDLE_INDICATOR"), X11Colors.DARK_SLATE_GRAY, X11Colors.WHITE, false, true, true));    colors.addRow(new IndicatorDescriptor(K_BOTT_IND, get("BOTTOM_INDICATOR"), X11Colors.DARK_SLATE_GRAY, X11Colors.WHITE, false, true, true));    colors = tab.addGroup(get("VO_PATH_AND_INDICATOR"));    colors.addRow(new PathDescriptor(VO_PATH, get("VO_PATH"), X11Colors.CADET_BLUE, 1.0f, null, true, true, true));    colors.addRow(new IndicatorDescriptor(VO_IND, get("VO_INDICATOR"), X11Colors.CADET_BLUE, X11Colors.WHITE, false, true, true));    tab = sd.addTab(get("COLORS2"));    colors = tab.addGroup(get("ADX_PATHS_AND_INDICATORS"));    colors.addRow(new PathDescriptor(ADX_PATH, get("ADX_PATH"), X11Colors.CADET_BLUE, 1.0f, null, true, true, true));    colors.addRow(new PathDescriptor(PDI_PATH, get("PDI_PATH"), X11Colors.RED, 1.0f, null, true, true, true));    colors.addRow(new PathDescriptor(NDI_PATH, get("NDI_PATH"), X11Colors.GREEN, 1.0f, null, true, true, true));    colors.addRow(new IndicatorDescriptor(ADX_IND, get("ADX_INDICATOR"), X11Colors.CADET_BLUE, X11Colors.WHITE, false, true, true));    colors.addRow(new IndicatorDescriptor(PDI_IND, get("PDI_INDICATOR"), X11Colors.RED, X11Colors.WHITE, false, true, true));    colors.addRow(new IndicatorDescriptor(NDI_IND, get("NDI_INDICATOR"), X11Colors.GREEN, X11Colors.WHITE, false, true, true));    colors = tab.addGroup(get("SMA_PATH_AND_INDICATOR"));    colors.addRow(new PathDescriptor(SMA_PATH, get("SMA_PATH"), X11Colors.RED, 1.0f, null, true, true, true));    colors.addRow(new IndicatorDescriptor(SMA_IND, get("SMA_INDICATOR"), X11Colors.RED, X11Colors.WHITE, false, true, true));    tab = sd.addTab(get("COLORS3"));    colors=tab.addGroup(get("PRICE_BAR_COLORS"));    colors.addRow(new ColorDescriptor(UP_COLOR, get("UP_COLOR"), defaults.getBlue()));    colors.addRow(new ColorDescriptor(DOWN_COLOR, get("DOWN_COLOR"), defaults.getYellow()));    colors.addRow(new ColorDescriptor(NEUTRAL_COLOR, get("NEUTRAL_COLOR"), defaults.getGrey()));    var guides=tab.addGroup(get("CCI_GUIDES"));    var topDesc=new GuideDescriptor(Inputs.TOP_GUIDE, get("CCI_TOP_GUIDE"), 100, 0, 999, 1, true);    topDesc.setLineColor(defaults.getRed());    guides.addRow(topDesc);    var mg=new GuideDescriptor(Inputs.MIDDLE_GUIDE, get("CCI_MIDDLE_GUIDE"), 0, -999, 999, 1, true);    mg.setDash(new float[] { 3, 3 });    guides.addRow(mg);    var bottomDesc=new GuideDescriptor(Inputs.BOTTOM_GUIDE, get("CCI_BOTTOM_GUIDE"), -100, 0, -999, 1, true);    bottomDesc.setLineColor(defaults.getGreen());    guides.addRow(bottomDesc);    var guides2=tab.addGroup(get("ADX_GUIDES"));    var topDesc2=new GuideDescriptor(ADX_TOP_GUIDE, get("ADX_TOP_GUIDE"), 40, 0, 999.1, .1, true);    topDesc2.setLineColor(defaults.getRed());    guides2.addRow(topDesc2);    var mg2=new GuideDescriptor(ADX_MID_GUIDE, get("ADX_MIDDLE_GUIDE"), 30, 0, 999.1, .1, true);    mg2.setDash(new float[] { 3, 3 });    guides2.addRow(mg2);    var bottomDesc2=new GuideDescriptor(ADX_BOTT_GUIDE, get("ADX_BOTTOM_GUIDE"), 20, 0, 999.1, .1, true);    bottomDesc2.setLineColor(defaults.getGreen());    guides2.addRow(bottomDesc2);        // Quick Settings (Tool Bar and Popup Editor)    sd.addQuickSettings(Inputs.INPUT);    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD, get("CCI_PERIOD"), 13, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(Inputs.PERIOD2, get("KELTNER_PERIOD"), 13, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(K_UPPER, K_LOWER, Inputs.METHOD);    sd.addQuickSettings(new SliderDescriptor(VF_PERIOD, get("VOLUME_FAST_PERIOD"), 1, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(VS_PERIOD, get("VOLUME_SLOW_PERIOD"), 20, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(ADX_PERIOD, get("ADX_PERIOD"), 10, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));    sd.addQuickSettings(new SliderDescriptor(SMA_PERIOD, get("SMA_PERIOD"), 8, 1, 9999, true, () -> Enums.Icon.SINE_WAVE.get()));        var desc = createRD();    desc.setLabelSettings(Inputs.PERIOD, K_UPPER, K_LOWER);        desc.exportValue(new ValueDescriptor(Values.TOP, get("K_TOP"), new String[] {Inputs.PERIOD, K_UPPER}));    desc.exportValue(new ValueDescriptor(Values.MIDDLE, get("K_MID"), new String[] {Inputs.PERIOD}));    desc.exportValue(new ValueDescriptor(Values.BOTTOM, get("K_BOTTOM"), new String[] {Inputs.PERIOD, K_LOWER}));    desc.declareSignal(Signals.BUY, get("BUY_SIGNAL"));    desc.declareSignal(Signals.SELL, get("SELL_SIGNAL"));    // Price plot (kelter channel)    desc.getPricePlot().setLabelSettings(Inputs.INPUT, Inputs.PERIOD, K_UPPER, K_LOWER);    desc.getPricePlot().setLabelPrefix("KC");    desc.getPricePlot().declarePath(Values.TOP, K_TOP_PATH);    desc.getPricePlot().declarePath(Values.MIDDLE, K_MID_PATH);    desc.getPricePlot().declarePath(Values.BOTTOM, K_BOTT_PATH);    desc.getPricePlot().declarePath(Values.SMA, SMA_PATH);        desc.getPricePlot().declareIndicator(Values.TOP, K_TOP_IND);    desc.getPricePlot().declareIndicator(Values.MIDDLE, K_MID_IND);    desc.getPricePlot().declareIndicator(Values.BOTTOM, K_BOTT_IND);    desc.getPricePlot().declareIndicator(Values.SMA, SMA_IND);    // Default Plot (CCI)    desc.setLabelSettings(Inputs.PERIOD);    desc.setLabelPrefix("CCI");    desc.setTabName("CCI");    desc.declarePath(Values.CCI, Inputs.PATH);    desc.declareIndicator(Values.CCI, Inputs.IND);    desc.getDefaultPlot().declareGuide(Inputs.TOP_GUIDE);    desc.getDefaultPlot().declareGuide(Inputs.MIDDLE_GUIDE);    desc.getDefaultPlot().declareGuide(Inputs.BOTTOM_GUIDE);    desc.setRangeKeys(Values.CCI);    // ADX Plot    Plot adxPlot = new Plot();    desc.addPlot(ADX_PLOT, adxPlot);    adxPlot.setLabelSettings(Inputs.INPUT, Inputs.PERIOD);    adxPlot.setLabelPrefix("ADX");    adxPlot.setTabName("ADX");    adxPlot.declarePath(Values.ADX, ADX_PATH);    adxPlot.declarePath(Values.PDI, PDI_PATH);    adxPlot.declarePath(Values.NDI, NDI_PATH);        adxPlot.declareIndicator(Values.ADX, ADX_IND);    adxPlot.declareIndicator(Values.PDI, PDI_IND);    adxPlot.declareIndicator(Values.NDI, NDI_IND);    adxPlot.declareGuide(ADX_TOP_GUIDE);    adxPlot.declareGuide(ADX_MID_GUIDE);    adxPlot.declareGuide(ADX_BOTT_GUIDE);    adxPlot.setMaxBottomValue(15);    adxPlot.setMinTopValue(85);    adxPlot.setRangeKeys(Values.ADX);    // VO Plot    Plot voPlot = new Plot();    desc.addPlot(VO_PLOT, voPlot);    voPlot.setLabelSettings(Inputs.INPUT, Inputs.PERIOD);    voPlot.setLabelPrefix("VO");    voPlot.setTabName("VO");    voPlot.declarePath(Values.VO, VO_PATH);    voPlot.declareIndicator(Values.VO, VO_IND);    voPlot.addHorizontalLine(new LineInfo(0, null, 1.0f, new float[] {3f, 3f}));    voPlot.setRangeKeys(Values.VO);  }  @Override  public void onLoad(Defaults defaults)  {    int p1=getSettings().getInteger(Inputs.PERIOD);    int p2=getSettings().getInteger(Inputs.PERIOD2);    int p3=getSettings().getInteger(VF_PERIOD);    int p4=getSettings().getInteger(VS_PERIOD);    int p5=getSettings().getInteger(ADX_PERIOD);    int p6=getSettings().getInteger(SMA_PERIOD);        int maxP = Math.max(Math.max(Math.max(Math.max(Math.max(p1, p2),         p3), p4), p5), p6);        setMinBars(maxP);  }    @Override  protected void calculate(int index, DataContext ctx)  {    int cciPeriod = getSettings().getInteger(Inputs.PERIOD);    int kPeriod = getSettings().getInteger(Inputs.PERIOD2);    int fastPeriod = getSettings().getInteger(VF_PERIOD);    int slowPeriod = getSettings().getInteger(VS_PERIOD);    int adxPeriod = getSettings().getInteger(ADX_PERIOD);    int smaPeriod = getSettings().getInteger(SMA_PERIOD);    int maxP = Math.max(Math.max(Math.max(Math.max(Math.max(cciPeriod, kPeriod),         fastPeriod), slowPeriod), adxPeriod), smaPeriod);    if (index < maxP) return;       Object input = getSettings().getInput(Inputs.INPUT);    var method = getSettings().getMAMethod(Inputs.METHOD);    Color neutralC = getSettings().getColor(NEUTRAL_COLOR);    Color upC=getSettings().getColor(UP_COLOR);    Color downC=getSettings().getColor(DOWN_COLOR);    var series = ctx.getDataSeries();    double price = series.getDouble(index, input, 0);    Double sma = series.sma(index, smaPeriod, input);    if (sma == null) return;    series.setDouble(index, Values.SMA, sma);            //CCI    double cci = Utility.CCI(series, index, cciPeriod);    series.setDouble(index, Values.CCI, cci);          //Start ADX    // Calculate the +DM, -DM and TR    Float pDm = series.getPositiveDM(index);    Float nDm = series.getNegativeDM(index);    Float tr = series.getTrueRange(index);    if (pDm == null || nDm == null || tr ==null) return;        series.setFloat(index, Values.PDM, pDm);    series.setFloat(index, Values.NDM, nDm);    series.setFloat(index, Values.TR, tr); //   if (index <= maxP *2 ) return; // not enough data to calculate the first set of averages        // Calculate the Average +DM, -DM and TR    Double pdMa = series.smma(index, adxPeriod, Values.PDM);    Double ndMa = series.smma(index, adxPeriod, Values.NDM);    Double tra = series.smma(index, adxPeriod, Values.TR);    if (pdMa == null || ndMa == null || tra == null) return;    // Determine the +DI, -DI and DX    double pdi = pdMa / tra * 100;    double ndi = ndMa / tra * 100;    double dx = Math.abs((pdMa - ndMa)) / (pdMa + ndMa) * 100;        series.setDouble(index, Values.DX, dx);    series.setDouble(index, Values.PDI, pdi);    series.setDouble(index, Values.NDI, ndi);     // Calculate the Average DX    Double adx = series.smma(index, adxPeriod, Values.DX);    if (adx == null) return;        series.setDouble(index, Values.ADX, adx);    double prevAdx = series.getDouble(index-1, Values.ADX, 0);    //End ADX        //Keltner Channels    double upperRange = getSettings().getDouble(K_UPPER);    double lowerRange = getSettings().getDouble(K_LOWER);        Double middle = series.ma(Enums.MAMethod.EMA, index, kPeriod, input);    Double atr = series.atr(index, kPeriod);    if (middle == null || atr == null) return;        double top = middle + (upperRange * atr);    double bottom = middle - (lowerRange * atr);    series.setDouble(index, Values.MIDDLE, middle);    series.setDouble(index, Values.TOP, top);    series.setDouble(index, Values.BOTTOM, bottom);        //Volume Oscillator    Double ma1 = series.ma(method, index, fastPeriod, Enums.BarInput.VOLUME);    Double ma2 = series.ma(method, index, slowPeriod, Enums.BarInput.VOLUME);    if (ma1 == null || ma2 == null) return;        double vo = ma1 - ma2;    series.setDouble(index, Values.VO, vo);        boolean up = adx > prevAdx && price > sma;    boolean down = adx > prevAdx && price < sma;   if (up) series.setPriceBarColor(index, upC);   if (down) series.setPriceBarColor(index, downC);   if (!up && !down) series.setPriceBarColor(index, neutralC);   series.setComplete(index);  }}