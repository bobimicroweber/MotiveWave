package com.motivewave.platform.study.strategies;import com.motivewave.platform.sdk.common.Coordinate;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.DataSeries;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Instrument;import com.motivewave.platform.sdk.common.MarkerInfo;import com.motivewave.platform.sdk.common.Util;import com.motivewave.platform.sdk.common.desc.DoubleDescriptor;import com.motivewave.platform.sdk.common.desc.InputDescriptor;import com.motivewave.platform.sdk.common.desc.MarkerDescriptor;import com.motivewave.platform.sdk.common.desc.ValueDescriptor;import com.motivewave.platform.sdk.draw.Marker;import com.motivewave.platform.sdk.order_mgmt.OrderContext;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;import com.motivewave.platform.study.general.Utility;import com.motivewave.platform.study.general3.Str;import com.motivewave.platform.study.strategies.Account.Signal;@StudyHeader(  namespace="com.motivewave",  rb="com.motivewave.platform.study.nls.strings2",  id="THREE_BAR_INSIDE_BAR",  name="NAME_THREE_BAR_INSIDE_BAR_STRATEGY",  desc="DESC_THREE_BAR_INSIDE_BAR",  label="LBL_TBIBS",  menu="MENU_GENERAL",  helpLink="http://www.motivewave.com/strategies/three_bar_inside_bar_strategy.htm",  overlay=true,  signals=true,  strategy=true,  autoEntry=true,  manualEntry=false,  supportsEnterOnActivate=false,  supportsUnrealizedPL=true,  supportsRealizedPL=true,  supportsTotalPL=true,  supportsPositionType=false,  supportsBarUpdates=false)public class ThreeBarInsideBarPatternStrategy extends Study{  enum Values { COND1, COND2, COND3 }  Marker activeMarker=null;  long activationTime=0;  double price=0;  Account acc=new Account(Account.PosType.SAR, Account.OrdType.MARKET, Account.CLOSED);  @Override  public void initialize(Defaults defaults)  {    Account.studyThis=this; // give Accounts access to get(str);    var sd=createSD();    var tab=sd.addTab(get("INPUTS"));    var inputs=tab.addGroup(get("INPUTS"));    inputs.addRow(new InputDescriptor(Str.INPUT1, get("POSITION_TYPE"), Account.PosType.values(), Account.PosType.SAR));    inputs.addRow(new InputDescriptor(Str.INPUT2, get("ORDER_TYPE"), Account.OrdType.values(), Account.OrdType.MARKET));    inputs.addRow(new InputDescriptor(Str.INPUT3, get("INPUT"), Enums.BarInput.CLOSE));    inputs.addRow(new DoubleDescriptor(Str.PROFIT_TARGET, get("PROFIT_TARGET"), .75, 0, 10.01, .01)); // .75    inputs.addRow(new DoubleDescriptor(Str.STOP_LOSS, get("STOP_LOSS"), .75, 0, 10.01, .01)); // .75    var markers=tab.addGroup("Markers");    markers.addRow(new MarkerDescriptor(Str.UP_MARKER1, get("ENTER_LONG"), Enums.MarkerType.TRIANGLE, Enums.Size.SMALL,        defaults.getGreen(), defaults.getLineColor(), true, true));    markers.addRow(new MarkerDescriptor(Str.DN_MARKER1, get("EXIT_LONG"), Enums.MarkerType.TRIANGLE, Enums.Size.SMALL,        defaults.getRed(), defaults.getLineColor(), true, true));    markers.addRow(new MarkerDescriptor(Str.DN_MARKER2, get("ENTER_SHORT"), Enums.MarkerType.TRIANGLE, Enums.Size.SMALL,        defaults.getBlue(), defaults.getLineColor(), true, true));    markers.addRow(new MarkerDescriptor(Str.UP_MARKER2, get("EXIT_SHORT"), Enums.MarkerType.TRIANGLE, Enums.Size.SMALL,        defaults.getYellow(), defaults.getLineColor(), true, true));    markers.addRow(new MarkerDescriptor(Str.ACTIVE1, get("ACTIVE"), Enums.MarkerType.CIRCLE, Enums.Size.MEDIUM,        defaults.getGreen(), defaults.getLineColor(), true, true));    var desc=createRD();    desc.exportValue(new ValueDescriptor(Signal.ENTER_LONG, Enums.ValueType.CHOICE, get("ENTER_LONG"), null));    desc.exportValue(new ValueDescriptor(Signal.EXIT_LONG, Enums.ValueType.CHOICE, get("EXIT_LONG"), null));    desc.exportValue(new ValueDescriptor(Signal.ENTER_SHORT, Enums.ValueType.CHOICE, get("ENTER_SHORT"), null));    desc.exportValue(new ValueDescriptor(Signal.EXIT_SHORT, Enums.ValueType.CHOICE, get("EXIT_SHORT"), null));    desc.declareSignal(Signal.ENTER_LONG, get("ENTER_LONG"));    desc.declareSignal(Signal.EXIT_LONG, get("EXIT_LONG"));    desc.declareSignal(Signal.ENTER_SHORT, get("ENTER_SHORT"));    desc.declareSignal(Signal.EXIT_SHORT, get("EXIT_SHORT"));    desc.setLabelSettings(Str.INPUT1, Str.INPUT2, Str.INPUT3, Str.STOP_REV, Str.PROFIT_TARGET, Str.STOP_LOSS);  }  @Override  public void onDeactivate(OrderContext ctx)  {    activationTime=0;    if (getSettings().isCloseOnDeactivate()) acc.close(ctx);    // setState(Enums.StrategyState.INACTIVE);    super.onDeactivate(ctx);    removeFigure(activeMarker);    DataContext dctx=ctx.getDataContext();    DataSeries series=dctx.getDataSeries();    int lastIndex=series.size() - 1;    // call calculate to display hypothetical past signals    for (int i=0; i < lastIndex; i++) {      calculate(i, dctx);    }  }  @Override  public void onActivate(OrderContext ctx)  {    // clearFigures();    DataSeries series=ctx.getDataContext().getDataSeries();    int ind=Utility.iif(series.isLastBarComplete(), series.size() - 1, series.size() - 2);    acc.close(ctx);    activationTime=series.getStartTime(ind);    double value=series.getLow(ind);    Coordinate c=new Coordinate(series.getStartTime(ind), value);    showActiveMarker(c);    super.onActivate(ctx);  }  @Override  public void onSignal(OrderContext ctx, Object signal)  {    Instrument instr=ctx.getInstrument();    float qty=(getSettings().getTradeLots() * instr.getDefaultQuantityAsFloat());    acc.processSignal(ctx, (Signal) signal, qty, price);  }  @Override  public void onLoad(Defaults defaults)  {    setMinBars(21);  }  @Override  protected void calculate(int index, DataContext ctx)  {    if (index < 2) { return; // not enough data    }    DataSeries series=ctx.getDataSeries();    if (series.getStartTime(index) < activationTime) return; // see onActivate above    acc.setPositionType((Account.PosType) getSettings().getInput(Str.INPUT1));    acc.orderType=(Account.OrdType) getSettings().getInput(Str.INPUT2);    Object key=getSettings().getInput(Str.INPUT3);    double pt=getSettings().getDouble(Str.PROFIT_TARGET);    double sl=getSettings().getDouble(Str.STOP_LOSS);    // Calculate Rsi    price=series.getDouble(index, key, 0);    double price1=series.getDouble(index - 1, key, 0);    double high=series.getHigh(index);    double high1=series.getHigh(index - 1);    double low=series.getLow(index);    double low1=series.getLow(index - 1);    acc.askPrice=(float) (price + (price * pt / 100));    acc.bidPrice=(float) (price - (price * pt / 100));    float stopLongPrice=0;    if (acc.enterLongPrice != 0) {      stopLongPrice=(float) (acc.enterLongPrice - (acc.enterLongPrice * sl / 100));    }    float stopShortPrice=Float.MAX_VALUE;    if (acc.enterShortPrice != 0) {      stopShortPrice=(float) (acc.enterShortPrice + (acc.enterShortPrice * sl / 100));    }    // Signals    boolean cond1=price > price1;    boolean cond2=high < high1 && low > low1;    boolean cond3=price < price1;    series.setBoolean(index, Values.COND1, cond1);    series.setBoolean(index, Values.COND2, cond2);    series.setBoolean(index, Values.COND3, cond3);    boolean cond12=series.getBoolean(index - 2, Values.COND1, false);    boolean cond21=series.getBoolean(index - 1, Values.COND2, false);    boolean cond32=series.getBoolean(index - 2, Values.COND3, false);    boolean enterLong=cond1 && cond21 && cond12;    boolean enterShort=cond3 && cond21 && cond32;    boolean exitLong=price < stopLongPrice;    boolean exitShort=price > stopShortPrice;    if (enterLong) {      Marker marker=new Marker(new Coordinate(series.getStartTime(index), low), Enums.Position.BOTTOM,          getSettings().getMarker(Str.UP_MARKER1));      marker.setTextValue(get("ENTER_LONG"));      marker.setTextPosition(Enums.Position.BOTTOM);      addFigure(marker);      ctx.signal(index, Signal.ENTER_LONG, get("ENTER_LONG_PRICE") + Util.round(price, 3), price);      series.setComplete(index);      return;    }    if (exitLong) {      Marker marker=new Marker(new Coordinate(series.getStartTime(index), high), Enums.Position.TOP,          getSettings().getMarker(Str.DN_MARKER1));      marker.setTextValue(get("EXIT_LONG"));      marker.setTextPosition(Enums.Position.TOP);      addFigure(marker);      ctx.signal(index, Signal.EXIT_LONG, get("EXIT_LONG_PRICE") + Util.round(price, 3), price);      series.setComplete(index);      return;    }    if (enterShort) {      Marker marker=new Marker(new Coordinate(series.getStartTime(index), high), Enums.Position.TOP,          getSettings().getMarker(Str.DN_MARKER2));      marker.setTextValue(get("ENTER_SHORT"));      marker.setTextPosition(Enums.Position.TOP);      addFigure(marker);      ctx.signal(index, Signal.ENTER_SHORT, get("ENTER_SHORT_PRICE") + Util.round(price, 3), price);      series.setComplete(index);      return;    }    if (exitShort) {      Marker marker=new Marker(new Coordinate(series.getStartTime(index), low), Enums.Position.BOTTOM,          getSettings().getMarker(Str.UP_MARKER2));      marker.setTextValue(get("EXIT_SHORT"));      marker.setTextPosition(Enums.Position.BOTTOM);      addFigure(marker);      ctx.signal(index, Signal.EXIT_SHORT, get("EXIT_SHORT_PRICE") + Util.round(price, 3), price);      series.setComplete(index);      return;    }    series.setComplete(index);  }  public void showActiveMarker(Coordinate c)  {    MarkerInfo markerInfo=getSettings().getMarker(Str.ACTIVE1);    activeMarker=new Marker(c, Enums.Position.BOTTOM, markerInfo);    activeMarker.setTextValue(get("ACTIVE"));    activeMarker.setTextPosition(Enums.Position.BOTTOM);    addFigure(activeMarker);  }}