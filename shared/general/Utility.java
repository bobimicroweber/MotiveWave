package com.motivewave.platform.study.general;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Calendar;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.DataSeries;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Enums.MAMethod;import com.motivewave.platform.study.general3.Numb;public class Utility{  public static String IND3 = "IND3";  public static String IND4 = "IND4";  public static String TOP_GUIDE1 = "TOP_GUIDE1";  public static String MID_GUIDE1 = "MID_GUIDE1";  public static String BOTT_GUIDE1 = "BOTT_GUIDE1";    public static String TOP_GUIDE2 = "TOP_GUIDE2";  public static String MID_GUIDE2 = "MID_GUIDE2";  public static String BOTT_GUIDE2 = "BOTT_GUIDE2";    // Linear regression line  public static double[] linRegLine(DataSeries series, int index, int period, Object key, int barIndex)  {    long sumX=0;    long sumX2=0;    double y=0.0;    double sumY=0.0;    double sumXy=0.0;    int x=0;    for (int i=index - period + 1; i <= index; i++) {      y=series.getDouble(i, key, 0);      if (y == 0) continue;      sumX=sumX + x;      sumY=sumY + y;      sumXy=sumXy + (x * y);      sumX2=sumX2 + (x * x);      x++;    }    // Calculate a and slope y = a + slope * x    double slope=((period * sumXy) - (sumX * sumY)) / ((period * sumX2) - (sumX * sumX));    double a=((sumY) - (slope * sumX)) / period;    double line=a + (slope * barIndex); // returns value of y at barIndex position.    double[] value= { line, slope };    return value;  }  public static double newCoeffR(DataSeries series, int index, int period, Object input)  {    double x=0.0;    double sumX=0.0;    double newCoeffR=0.0;    double upEq=0.0;    double lowEq1=0.0;    double lowEq2=0.0;    double lowEqT=0.0;    double sumXV=0.0;    double sumV=0.0;    double sumXSq=0.0;    double sumVSq=0.0;    double v=0.0;    for (int i=index - period + 1; i <= index; i++) {      v=series.getDouble(i, input, 0.0);      if (v == 0) continue;      sumX=sumX + x;      sumV=sumV + v;      sumXV=sumXV + (x * v);      sumXSq=sumXSq + (x * x);      sumVSq=sumVSq + (v * v);      x++;    }    double avX=sumX / x;    double avV=sumV / x;    upEq=sumXV - (period * avX * avV);    lowEq1=sumXSq - (period * avX * avX);    lowEq2=sumVSq - (period * avV * avV);    if (lowEq1 * lowEq2 > 0.0) lowEqT=Math.sqrt(lowEq1 + lowEq2);    if (lowEqT != 0.0) newCoeffR=upEq / lowEqT;    return newCoeffR;  }  public static double[] sumMore(DataSeries series, int index, int period, Object input)  {    double v=0.0;    double sumV=0.0;    double sumV2=0.0;    double sumVx=0.0;    double sumX=0.0;    double sumX2=0.0;    double avX=0.0;    double avV=0.0;    double ret[]= { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };    long x=0;    for (int i=index - period + 1; i <= index; i++) {      v=series.getDouble(i, input, 0.0); // v=value user input usually close.      sumV=sumV + v;      sumV2=sumV2 + (v * v);      sumVx=sumVx + (v * x);      sumX=sumX + x;      sumX2=sumX2 + (x * x);      x++;    }    avV=sumV / period;    avX=sumX / x;    ret[0]=sumV;    ret[1]=sumV2;    ret[2]=sumVx;    ret[3]=sumX2;    ret[4]=avX;    ret[5]=avV;    return ret;    // double sumV = ret[0]; //v=value user input usually close.    // double sumV2 = ret[1];    // double sumVx = ret[2];    // double sumX2 = ret[3];    // double avX = ret[4];    // double avV = ret[5];  }  public static double[] bollingerBands(DataSeries series, int index, int period, double sdUp, double sdDn, Object key)  {    double stdDev=series.std(index, period, key);    double ma=series.sma(index, period, key);    double bbTop=ma + (stdDev * sdUp); // Bollinger Band top    double bbBott=ma - (stdDev * sdDn);    double bbDiff=bbTop - bbBott;    return new double[] { bbTop, bbBott, ma, stdDev, bbDiff };  }  public static double momentum(DataContext ctx, int index, int period, Object key)  {    DataSeries series=ctx.getDataSeries();    double price=series.getDouble(index, key);    double priorP=series.getDouble(index - period, key);    return (price - priorP);  }  public static double cmo(DataContext ctx, int index, int period, Object key)  {    DataSeries series=ctx.getDataSeries();    double price=0, prevP=0;    double sumD=0;    for (int i=index - period + 1; i <= index; i++) {      price=series.getDouble(i, key, 0);      prevP=series.getDouble(i - 1, key, 0);      sumD=sumD + (Math.abs(price - prevP));    }    double priorP=series.getDouble(index - period, key, 0);    price=series.getDouble(index, key, 0); // prop not necessary    double cmo=100 * (price - priorP) / sumD;    return cmo;  }  public static double upDnVol(DataSeries series, int index, int period, Object key)  {    double volume=0, price=0, prevP=0;    double upVol=0, dnVol=0, upDnVol=0;    for (int i=index - period + 1; i <= index; i++) {      volume=series.getVolume(i);      price=series.getDouble(i, key, 0);      prevP=series.getDouble(i - 1, key, 0);      if (price >= prevP) upVol=upVol + volume;      if (price < prevP) dnVol=dnVol + volume;    }    if (dnVol != 0) upDnVol=upVol / dnVol;    return upDnVol;  }  public static Double macd(DataSeries series, int index, int period1, int period2, Object key, MAMethod method)  {    Double ma1=series.ma(method, index, period1, key);    Double ma2=series.ma(method, index, period2, key);    if (ma1 == null || ma2 == null) return 0.0;    return ma1 - ma2;  }  public static double stdErr(DataSeries series, int index, int period, Object key)  {    // Calculates standard error as compared to the linear regression line    long sumX=0;    long sumX2=0;    double y=0.0;    double sumY=0.0;    double sumXy=0.0;    int x=0;    for (int i=index - period + 1; i <= index; i++) {      y=series.getDouble(i, key, 0);      if (y == 0) continue;      sumX=sumX + x;      sumY=sumY + y;      sumXy=sumXy + (x * y);      sumX2=sumX2 + (x * x);      x++;    }    x=0;    // LR line y = a + slope * x    double slope=((period * sumXy) - (sumX * sumY)) / ((period * sumX2) - (sumX * sumX));    double a=((sumY) - (slope * sumX)) / period;    double sumSqrs=0.0;    double lrl=0.0; // linear regression line value    for (int i=index - period + 1; i <= index; i++) {      y=series.getDouble(i, key, 0);      if (y == 0) continue;      lrl=a + (slope * x);      sumSqrs=sumSqrs + Math.pow(y - lrl, 2); // sum the squares of price minus LR line value      x++;    }    double sdErr=Math.sqrt(sumSqrs / period);    return sdErr;  }  // Stochastic fast K  public static double stochK(DataSeries series, int index, int period, Object key)  {    double price=series.getDouble(index, key, 0);    double lowest=series.lowest(index, period, Enums.BarInput.LOW);    double highest=series.highest(index, period, Enums.BarInput.HIGH);    return (price - lowest) / (highest - lowest) * 100.0;  }  public static boolean odd(int num)  {    int mid=num / 2;    double v=num / 2.0;    double diff=Math.abs(v - mid);    return (diff > .01);  }  // returns true if num is exact multiple of mult  public static boolean isMult(int num, int mult)  {    int mid=num / mult;    double v=(double) num / mult;    double diff=Math.abs(v - mid);    return (diff == 0);  }  // if period is odd return mid price, if even, return average of 2 centre positions  public static double median(DataSeries series, int index, int period, Object key)  {    int mid=(period + 1) / 2;    double price=series.getDouble(index - mid, key, 0);    if (odd(period)) return price;    double price2=series.getDouble(index - mid + 1, key, 0);    return (price + price2) / 2.0;  }  // rounds double number to dec decimal places  public static double round(double number, int dec)  {    double fac=Math.pow(10, dec);    int rd=(int) ((number * fac) + .5);    return rd / fac;  }  public static double[] sdDev(DataSeries series, int index, int period, Object key)  {    double price=0, dev=0, totD=0, totP=0, totM=0;    double sd=0, sdPlus=0, sdMinus=0;    int cUp=0, cDown=0, cTotal=0;    double av=series.sma(index, period, key);    for (int i=index - period + 1; i <= index; i++) {      price=series.getDouble(i, key, 0);      dev=price - av;      totD=totD + (dev * dev);      cTotal++;      if (dev > 0) {        totP=totP + (dev * dev);        cUp++;      }      else {        totM=totM + (dev * dev);        cDown++;      }    }    sd=Math.sqrt(totD / cTotal);    if (cUp != 0) sdPlus=Math.sqrt(totP / cUp);    if (cDown != 0) sdMinus=Math.sqrt(totM / cDown);    return new double[] { sd, sdPlus, sdMinus };  }  public static double ulcer(DataSeries series, int index, int period, Object key)  {    double sumSq=0, price=0, dd=0;    double peak=0;    for (int i=index - period + 1; i <= index; i++) {      price=series.getDouble(i, key, 0);      if (price > peak) peak=price;      else {        dd=(100 * (price / peak) - 1);        sumSq=sumSq + (dd * dd);      }    }    return Math.sqrt(sumSq / period);  }  // call from calculate on last index if user requested.  // public static double avToPeakCount(DataSeries series, double topG, double bottG, Object key)  // {  // int countH = 0, xH = 0, sumChigh = 0, avH = 0;  // double price = 0, prevP = 0;  // int endIndex = series.getEndIndex()-1;  // for (int i = 2; i <= endIndex; i++) {  // price = series.getDouble(i, key, 0);  // prevP = series.getDouble(i-1, key, 0);  // if (prevP > topG && price < topG) {  // countH = highCount(series, i, topG, key);  // if (countH == 0) continue;  // sumChigh = sumChigh + countH;  // xH++;  // }  // }  // if (xH != 0) avH = sumChigh / xH;  // return avH;  // }  // returns the number of increases before price peaks  public static int highCount(DataSeries series, int index, double topG, Object key)  {    double price=0;    int indP=0, startI=0;    // find startI    for (int i=index - 1; i > 0; i--) {      price=series.getDouble(i, key, 0);      if (price < topG) {        startI=i;        break;      }    }    if (startI == 0) return 0;    // find where peak occurred    double peak=0;    for (int i=startI + 1; i <= index; i++) {      price=series.getDouble(i, key, 0);      if (price > peak) {        peak=price;        indP=i;      }    }    int count=0;    double prevP=peak;    // count numb of price increases before the price peaked    for (int i=indP; i > startI; i--) {      price=series.getDouble(i, key, 0);      if (price > prevP) break;      prevP=price;      count++;    }    return count;  }  public static boolean isFibonacci(int n)  {    if (n > 6765) return false;    if (n <= 144) {      if (n == 5 || n == 8 || n == 13 || n == 21 || n == 34 || n == 55 || n == 89 || n == 144) return true;    }    if (n == 233 || n == 377 || n == 610 || n == 987 || n == 1597 || n == 2584 || n == 4181 || n == 6765) return true;    return false;  }  public static boolean isLucas(int n)  {    if (n > 3571) return false;    if (n <= 76) {      if (n == 3 || n == 4 || n == 7 || n == 11 || n == 18 || n == 29 || n == 47 || n == 76) return true;    }    if (n == 123 || n == 199 || n == 322 || n == 512 || n == 843 || n == 1364 || n == 2207 || n == 3571) return true;    return false;  }  // returns the bar number of the highest price for the period  public static double[] highestBar(DataSeries series, int index, int period, Object key)  {    double price=0, peak=0;    double maxIndex=0;    int startIndex=index - period;    for (int i=startIndex; i < index; i++) {      price=series.getDouble(i, key, 0);      if (price > peak) {        peak=price;        maxIndex=i;      }    }    return new double[] { peak, maxIndex };  }  // returns the bar number of the lowest price for the period  public static double[] lowestBar(DataSeries series, int index, int period, Object key)  {    double price=0, peak=Double.MAX_VALUE;    int minIndex=0;    int startIndex=index - period;    for (int i=startIndex; i < index; i++) {      price=series.getDouble(i, key, 0);      if (price < peak) {        peak=price;        minIndex=i;      }    }    return new double[] { peak, minIndex };  }  public static double perCentB(DataSeries series, int period, int index, double std, Object key)  {    double value=series.getDouble(index, key);    double ma=series.sma(index, period, key);    Double dev=series.std(index, period, key) * std;    double upperBand=ma + dev;    double lowerBand=ma - dev;    return (value - lowerBand) / (upperBand - lowerBand);  }  public static double CCI(DataSeries series, int index, int period)  {    double tp[] = new double[period];    int j = 0;    double sum = 0;    for(int i = index-period+1; i <= index; i++) {      tp[j] = series.getTypicalPrice(i);      sum = sum + tp[j];      j++;    }    double smaTp = sum / period;          // Calculate the Mean Deviation    sum = 0;    for(int i = 0; i < tp.length; i++) {      sum = sum + Math.abs(tp[i]-smaTp);    }        double md = sum / period;    return (tp[period-1] - smaTp) / (0.015*md);  //CCI  }    public static String dateTime(long msec, int retValue){    Calendar dat = Calendar.getInstance();    dat.setTimeInMillis(msec);    int yr = dat.get(Calendar.YEAR);    int month = dat.get(Calendar.MONTH) + 1; //jan = 0    int day = dat.get(Calendar.DAY_OF_MONTH);    int hr = dat.get(Calendar.HOUR_OF_DAY);    int min = dat.get(Calendar.MINUTE);    if (retValue == Numb.DATE){      return Integer.toString(yr) + "/" + Integer.toString(month) + "/" + Integer.toString(day);    }    if (retValue == Numb.TIME) {      return Integer.toString(hr) + "/" + Integer.toString(min);    }   return Integer.toString(yr) + "/" + Integer.toString(month) + "/" + Integer.toString(day) + "/"   + Integer.toString(hr) + "/" + Integer.toString(min);  }  public static int sign(double var1, double var2){    if (var1 > var2) return 1;    return -1;      }   // immediate if's to simulate other languages  public static double iif(boolean cond, double ret1, double ret2)  {    if (cond) return ret1;    return ret2;  }  public static long iif(boolean cond, long ret1, long ret2)  {    if (cond) return ret1;    return ret2;  }  public static int iif(boolean cond, int ret1, int ret2)  {    if (cond) return ret1;    return ret2;  }  public static boolean iif(boolean cond, boolean cond1, boolean cond2)  {    if (cond) return cond1;    return cond2;  }  public static Object iif(boolean cond, Object obj1, Object obj2)  {    if (cond) return obj1;    return obj2;  }    public static int max(int v1, int v2, int v3, int v4){    return Math.max(Math.max(Math.max(v1,  v2), v3), v4);  }    public static void mess(String str){    String mfile = "c:\\eclipse\\Utilities\\Message.txt";      try {            File source = new File(mfile);      File temp = new File(mfile + "temp");      //Create input stream      FileReader fr = new FileReader(source);      BufferedReader in = new BufferedReader(fr);      //Create output stream      FileWriter fw = new FileWriter(temp);      BufferedWriter out = new BufferedWriter(fw);      String line = "";      while (true){         line = in.readLine();        if (line == null) break;        out.write(line + '\r' + '\n');      }      out.write(str + '\r' + '\n');      in.close();      out.close();      boolean deleted = source.delete();      if (deleted) temp.renameTo(source);      } catch (IOException e) {          System.out.println("Error" + e.toString());      } catch (SecurityException se) {          System.out.println("Error" + se.toString());      }  }   }           