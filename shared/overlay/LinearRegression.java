package com.motivewave.platform.study.overlay;import java.awt.geom.Point2D;import java.util.ArrayList;import com.motivewave.common.Util;import com.motivewave.platform.sdk.common.Coordinate;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Inputs;import com.motivewave.platform.sdk.common.desc.InputDescriptor;import com.motivewave.platform.sdk.common.desc.IntegerDescriptor;import com.motivewave.platform.sdk.common.desc.PathDescriptor;import com.motivewave.platform.sdk.common.desc.SliderDescriptor;import com.motivewave.platform.sdk.draw.Line;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;/** Linear Regression Line */@StudyHeader(  namespace="com.motivewave",  id="ID_LIN_REG",  rb="com.motivewave.platform.study.nls.strings2",  name="NAME_LINEAR_REGRESSION",  label="LBL_LGL",  desc="DESC_LINEAR_REG",  helpLink="http://www.motivewave.com/studies/linear_regression.htm",  overlay=true,  studyOverlay=true)public class LinearRegression extends Study{  enum Values { LINREG }  @Override  public void initialize(Defaults defaults)  {    var sd = createSD();    var tab = sd.addTab(get("TAB_GENERAL"));    var grp=tab.addGroup(get("INPUTS"));    grp.addRow(new InputDescriptor(Inputs.INPUT, get("INPUT"), Enums.BarInput.CLOSE));    grp.addRow(new IntegerDescriptor(Inputs.BAR, get("REGRESSION_BARS"), 40, 1, 999, 1));    grp.addRow(new IntegerDescriptor(Inputs.BARS, get("FUTURE_BARS"), 1, 0, 10, 1));    grp = tab.addGroup(get("PATH"));    grp.addRow(new PathDescriptor(Inputs.PATH, get("PATH"), defaults.getLineColor(), 1.0f, null, true, false, true));    // Quick Settings (Tool Bar and Popup Editor)    sd.addQuickSettings(Inputs.INPUT);    sd.addQuickSettings(new SliderDescriptor(Inputs.BAR, get("REGRESSION_BARS"), 40, 1, 9999, true, () -> Enums.Icon.ARROW_LEFT.get()));    sd.addQuickSettings(new SliderDescriptor(Inputs.BARS, get("FUTURE_BARS"), 1, 1, 9999, true, () -> Enums.Icon.ARROW_RIGHT.get()));    sd.addQuickSettings(Inputs.PATH);    var desc=createRD();    desc.declarePath(Values.LINREG, Inputs.PATH);    desc.setLabelSettings(Inputs.INPUT, Inputs.BAR, Inputs.BARS);    desc.setRangeKeys(Values.LINREG);  }  @Override  public void onLoad(Defaults defaults)  {    int p1=getSettings().getInteger(Inputs.BAR);    setMinBars(p1);  }  @Override  protected void calculateValues(DataContext ctx)  {    var series=ctx.getDataSeries();    clearFigures();    var path=getSettings().getPath(Inputs.PATH);    if (!path.isEnabled()) return;    var input=getSettings().getInput(Inputs.INPUT, Enums.BarInput.CLOSE); // Usually based on close.    int end=series.size();    int bars=getSettings().getInteger(Inputs.BAR, 40);    int start=end - bars;    int futureBars=getSettings().getInteger(Inputs.BARS);    // Calculate the points using real values.    // Note: Alternatively we could use graph values for x and y, but this would produce different results in semi-log    // Not sure if this is good or bad...    var points = new ArrayList<Point2D>();    int x = 0;    for(int i = start; i < end; i++) {      if (i < 0) continue;      Double y = series.getDouble(i, input);      if (y == null) continue;      points.add(new Point2D.Double(x, round(y)));      x++;    }    double result[] = Util.leastSquares(points);    double m = result[0];    double b = result[1];    var line=new Line(new Coordinate(series.getStartTime(start), b),                        new Coordinate(series.getStartTime(end), m*x + b), path);    line.setExtendRight(futureBars);    addFigure(line);  }}