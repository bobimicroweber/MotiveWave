package com.motivewave.platform.study.overlay;import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.Insets;import java.awt.Rectangle;import java.awt.geom.Line2D;import java.awt.geom.Point2D;import java.util.ArrayList;import java.util.Calendar;import java.util.GregorianCalendar;import java.util.List;import java.util.TimeZone;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.DataSeries;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.DrawContext;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.Inputs;import com.motivewave.platform.sdk.common.PathInfo;import com.motivewave.platform.sdk.common.Util;import com.motivewave.platform.sdk.common.desc.BooleanDescriptor;import com.motivewave.platform.sdk.common.desc.ColorDescriptor;import com.motivewave.platform.sdk.common.desc.FontDescriptor;import com.motivewave.platform.sdk.common.desc.InputDescriptor;import com.motivewave.platform.sdk.common.desc.PathDescriptor;import com.motivewave.platform.sdk.draw.Figure;import com.motivewave.platform.sdk.draw.Text;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;/** StockMarketExchanges 170 */@StudyHeader(  namespace="com.motivewave",  id="STOCK_MARKET_EXCHANGES",  rb="com.motivewave.platform.study.nls.strings2",  name="NAME_MARKET_EXCHANGES",  label="LBL_MKTEX",  desc="DESC_MKTEX",  helpLink="http://www.motivewave.com/studies/market_exchanges.htm",  requiresVolume=false,  signals=false,  overlay=true,  studyOverlay=true,  supportsBarUpdates=false)public class MarketExchanges extends Study{  final static int MinutesPerDay=60 * 24;  final static String SHOW_STATE="showState", SHOW_EX_LETTERS="showEx";    List<MarketEx> exchanges=new ArrayList();  @Override  public void initialize(Defaults defaults)  {    exchanges.add(new MarketEx("New Zealand GMT+12", "NZSX", "Pacific/Auckland", "10:00", "17:00"));    exchanges.add(new MarketEx("Australian GMT+10", "ASX", "Australia/Sydney", "9:50", "16:12"));    exchanges.add(new MarketEx("Tokyo GMT+9", "TSE", "Japan", "9:00", "15:00"));    exchanges.add(new MarketEx("Korea GMT+9", "KRX", "Asia/Soeul", "9:00", "15:00"));    exchanges.add(new MarketEx("Bursa Malaysia GMT+8", "MYX", "Asia/Brunei", "9:00", "17:00"));    exchanges.add(new MarketEx("Singapore GMT+8", "SGX", "Asia/Singapore", "9:00", "17:00"));    exchanges.add(new MarketEx("Taiwan GMT+8", "TSE", "Asia/Taipei", "9:00", "13:30"));    exchanges.add(new MarketEx("Hong Kong GMT+8", "HKFE", "Asia/Hong_Kong", "9:15", "16:00"));    exchanges.add(new MarketEx("Hong Kong GMT+8", "HKEX", "Asia/Hong_Kong", "9:00", "16:00"));    exchanges.add(new MarketEx("Shanghai GMT+8", "SSE", "Asia/Shanghai", "9:30", "15:00"));    exchanges.add(new MarketEx("Shenzhen GMT+8", "SZSE", "Asia/Shanghia", "9:00", "15:00"));    exchanges.add(new MarketEx("Philippine GMT+8", "PSE", "Asia/Manila", "9:30", "15:30"));    exchanges.add(new MarketEx("Indonesia GMT+7", "IDX", "Asia/Bangkok", "9:30", "16:00"));    exchanges.add(new MarketEx("Thialand GMT+7", "SET", "Asia/Bangkok", "10:00", "16:30"));    exchanges.add(new MarketEx("Bombay GMT+5.5", "BSE", "Asia/Colombo", "9:15", "15:30"));    exchanges.add(new MarketEx("India GMT+5.5", "NSE", "Asia/Kolkata", "9:15", "15:30"));    exchanges.add(new MarketEx("Colombo GMT+5.5", "CSE", "Asia/Colombo", "9:30", "14:30"));    exchanges.add(new MarketEx("Moscow GMT+4", "MICEX", "Europe/Moscow", "10:00", "19:00"));    exchanges.add(new MarketEx("Saudi GMT+3", "TADAWUL", "Asia/Riyadh", "11:00", "15:30"));    exchanges.add(new MarketEx("Johannesburg GMT+2", "JSE", "Africa/Johannesburg", "9:00", "17:00"));    exchanges.add(new MarketEx("Frankfurt GMT+1", "FSX", "Europe/Berlin", "8:00", "22:00"));    exchanges.add(new MarketEx("Istanbul GMT+2", "ITSE", "Asia/Istanbul", "9:30", "17:30"));    exchanges.add(new MarketEx("Wiener Borse GMT+1", "AG", "Europe/Vienna", "8:55", "17:35"));    exchanges.add(new MarketEx("Ukrainian GMT+2", "UX", "EET", "10:00", "17:30"));    exchanges.add(new MarketEx("Amman GMT+2", "ASE", "Asia/Amman", "10:00", "12:00"));    exchanges.add(new MarketEx("Euronext Paris GMT+1", "EPA", "Europe/Paris", "9:00", "17:30"));    exchanges.add(new MarketEx("Swiss GMT+1", "SIX", "Europe/Amsterdam", "9:00", "17:30"));    exchanges.add(new MarketEx("Berne GMT+1", "BX", "Europe/Berlin", "9:00", "16:30"));    exchanges.add(new MarketEx("Spanish GMT+1", "BME", "Europe/Madrid", "9:00", "17:30"));    exchanges.add(new MarketEx("Milan GMT+1", "MTA", "Europe/Rome", "9:00", "17:25"));    exchanges.add(new MarketEx("Euronext Amsterdam GMT+1", "AMS", "Europe/Amsterdam", "9:00", "17:40"));    exchanges.add(new MarketEx("Helsinki GMT+2", "OMX", "Europe/Helsinki", "10:00", "18:30"));    exchanges.add(new MarketEx("Stockholm GMT+1", "OMX", "Europe/Stockholm", "9:00", "17:30"));    exchanges.add(new MarketEx("Oslo GMT+1", "OSE", "Europe/Oslo", "9:00", "17:30"));    exchanges.add(new MarketEx("Copenhagen GMT+1", "CSE", "Europe/Copenhagen", "9:00", "17:00"));    exchanges.add(new MarketEx("Riga GMT+2", "OMXR", "Europe/Riga", "10:00", "16:00"));    exchanges.add(new MarketEx("Warsaw GMT+1", "GPW", "Europe/Warsaw", "9:00", "17:30"));    exchanges.add(new MarketEx("Nigerian GMT+1", "NSE", "Africa/Logos", "10:00", "16:00"));    exchanges.add(new MarketEx("London GMT+0", "LSE", "Europe/London", "8:00", "16:30"));    exchanges.add(new MarketEx("Irish GMT+0", "ISE", "Europe/London", "8:00", "16:30"));    exchanges.add(new MarketEx("Bolsa de Valores-3", "Bovespa", "America/Argentina/Buenos_Aires", "10:00", "17:00"));    exchanges.add(new MarketEx("New York GMT-5", "NYSE", "America/New_York", "9:30", "16:00"));    exchanges.add(new MarketEx("NASDAQGMT-5", "NASDAQ", "America/New_York", "9:30", "16:00"));    exchanges.add(new MarketEx("Toronto GMT-5", "TSX", "America/Toronto", "9:30", "16:00"));    exchanges.add(new MarketEx("Mexican GMT-6", "BMV", "America/Mexico_City", "8:30", "15:00"));    // exchanges.add(new MarketEx("FOREX New York GMT-5", "FOREX", "America/New_York", "8:00", "16:00"));    // exchanges.add(new MarketEx("FOREX Tokyo GMT+9", "FOREX", "Japan", "8:00", "16:00"));    // exchanges.add(new MarketEx("FOREX Sydney GMT+10", "FOREX", "Australia/Sydney", "8:00", "16:00"));    // exchanges.add(new MarketEx("FOREX London GMT+0", "FOREX", "Europe/London", "8:00", "16:00"));    // exchanges.add(new MarketEx("FOREX Frankfurt GMT+1", "FOREX", "Europe/Berlin", "8:00", "16:00"));    // exchanges.add(new MarketEx("Chicago GMT-5", "CME", "America/Chicago", "9:30", "14:00"));    var sd=createSD();    var tab=sd.addTab(get("TAB_GENERAL"));    var inputs=tab.addGroup(get("INPUTS"));    inputs.addRow(new InputDescriptor(Inputs.INPUT, get("LBL_MARKET_EXCHANGE"), exchanges.toArray(), exchanges.get(0)));    inputs.addRow(new BooleanDescriptor(SHOW_STATE, get("LBL_SHOW_STATE"), true));    inputs.addRow(new BooleanDescriptor(SHOW_EX_LETTERS, get("LBL_SHOW_EXCHANGE_LETTERS"), true));    inputs.addRow(new FontDescriptor(Inputs.FONT, get("FONT"), defaults.getFont()));    var settings=tab.addGroup(get("LINE"));    settings.addRow(new PathDescriptor(Inputs.PATH, get("Open"), defaults.getGreen(), 1.0f, new float[] { 3.0f, 3.0f }, true, false, true));    settings.addRow(new PathDescriptor(Inputs.PATH2, get("Close"), defaults.getRed(), 1.0f, new float[] { 3.0f, 3.0f }, true, false, true));    settings.addRow(new ColorDescriptor(Inputs.TOP_COLOR, get("TEXT_COLOR"), defaults.getGrey()));    // Quick Settings (Tool Bar and Popup Editor)    sd.addQuickSettings(Inputs.INPUT, SHOW_STATE, SHOW_EX_LETTERS, Inputs.FONT, Inputs.PATH, Inputs.PATH2, Inputs.TOP_COLOR);    var desc=createRD();    desc.setLabelSettings(Inputs.INPUT);    setMinBars(20);  }  @Override  protected void calculateValues(DataContext ctx)  {    var series=ctx.getDataSeries();    int barMin=0;    var bar=series.getBarSize();    if (bar.getType() == Enums.BarSizeType.LINEAR) barMin=bar.getInterval();    else return;    if (MinutesPerDay / barMin <= 1.0) return;    boolean showState=getSettings().getBoolean(SHOW_STATE);    boolean showCall=getSettings().getBoolean(SHOW_EX_LETTERS);    var fi=getSettings().getFont(Inputs.FONT);    Font f=fi.getFont();    var remObj=(MarketEx) getSettings().getInput(Inputs.INPUT, exchanges.get(0));    clearFigures();    String shLett=remObj.letters;    TimeZone tz=remObj.timeZone;    TimeZone defTz=TimeZone.getDefault();    int hrOpens=remObj.hrOpen;    int minOpens=remObj.minOpen;    int hrCloses=remObj.hrClose;    int minCloses=remObj.minClose;    String sHldRem=remObj.strTimeZone; // use time zone string of remote market for holiday identifier    String sHldCur=defTz.getDisplayName();    var calCurBar=new GregorianCalendar(); // calendar for current bar    var calPrevBar=new GregorianCalendar(); // calendar for previous bar    var calRemOpen=new GregorianCalendar(); // calendar for remote market open    var calRemClose=new GregorianCalendar(); // calendar for remote market close    var calUtil=new GregorianCalendar(); // utility calendar    Holidays hldRem=new Holidays(sHldRem); // uses time zone string for holiday object    Holidays hldCur=new Holidays(sHldCur);    calRemOpen.setTimeZone(tz);    calRemClose.setTimeZone(tz);    int newDayOfMth=0;    int newDayOfYr=0, oldDayOfYr=0;    int dayYrOutOpen=0, dayYrOutClose=0, hDay=0;    int yr=0, mth=0;    String oHrStr="", oMinStr="", oTimeStr="", cMinStr="", cHrStr="", cTimeStr="";    String patch="", oArrow="-", cArrow="-";    Integer oHr=0, oMin=0, cHr=0, cMin=0;    long xtime=0;    int endIndex=series.getEndIndex();    var path1=getSettings().getPath(Inputs.PATH);    var path2=getSettings().getPath(Inputs.PATH2);    boolean path1Enabled=getSettings().getPath(Inputs.PATH).isEnabled();    boolean path2Enabled=getSettings().getPath(Inputs.PATH2).isEnabled();    Color tcolor=getSettings().getColor(Inputs.TOP_COLOR, ctx.getDefaults().getGrey());    long curBarTime=0, prevBarTime=0, remOpenTime=0, remCloseTime=0;    boolean holidayOpen=false, holidayClose=false;    int fiveDays=MinutesPerDay * 5 / barMin;    // cur = current, prev = previous, rem = remote, cal = calendar    for (int i=1; (i <= endIndex + fiveDays); i++) {      curBarTime=series.getStartTime(i);      prevBarTime=series.getStartTime(i - 1);      calCurBar.setTimeInMillis(curBarTime);      calPrevBar.setTimeInMillis(prevBarTime);      calCurBar.getTimeInMillis(); // set fields      calPrevBar.getTimeInMillis(); // set fields      yr=calCurBar.get(Calendar.YEAR);      mth=calCurBar.get(Calendar.MONTH);      newDayOfYr=calCurBar.get(Calendar.DAY_OF_YEAR);      newDayOfMth=calCurBar.get(Calendar.DAY_OF_MONTH);      holidayOpen=holidayClose=false;      if (newDayOfYr != oldDayOfYr) { // if current bar causes change of day, reset open and close dates        oArrow=cArrow="-";        // reset open date        calRemOpen.clear();        calRemOpen.setTimeZone(tz); // set to remote time zone        calRemOpen.set(yr, mth, newDayOfMth, hrOpens, minOpens, 0);        calRemOpen.getTimeInMillis(); // force calendar calculations        calRemOpen.setTimeZone(defTz); // change back to local time zone        calRemOpen.getTimeInMillis(); // force calendar calculations        dayYrOutOpen=calRemOpen.get(Calendar.DAY_OF_YEAR);        oHr=calRemOpen.get(Calendar.HOUR_OF_DAY);        oMin=calRemOpen.get(Calendar.MINUTE);        oHrStr=Integer.toString(oHr);        oMinStr=Integer.toString(oMin);        if (oMinStr.length() == 1) patch=":0";        else patch=":";        oTimeStr=oHrStr + patch + oMinStr;        if (dayYrOutOpen != newDayOfYr) { // did change in time zone create a day change for opening calendar          if (dayYrOutOpen > newDayOfYr) {            hDay=-1;            oArrow=">";          }          else {            hDay=1;            oArrow="<";          }          calUtil.set(yr, mth, newDayOfMth + hDay, hrOpens, minOpens, 0); // use utility calendar for holiday check          calUtil.getTimeInMillis(); // force calendar calculations          holidayOpen=hldRem.isHoliday(calUtil); // is it a holiday at remote exchange?          if (!holidayOpen) { // if not a holiday at remote exchange reset remote exchange calendar            calRemOpen.clear();            calRemOpen.set(yr, mth, newDayOfMth, oHr, oMin, 0);          }        }        remOpenTime=calRemOpen.getTimeInMillis();        // reset closing date with same steps as opening date above        calRemClose.clear();        calRemClose.setTimeZone(tz);        calRemClose.set(yr, mth, newDayOfMth, hrCloses, minCloses, 0);        calRemClose.getTimeInMillis(); // force calendar calculations        calRemClose.setTimeZone(defTz);        calRemClose.getTimeInMillis(); // force calendar calculations        dayYrOutClose=calRemClose.get(Calendar.DAY_OF_YEAR);        cHr=calRemClose.get(Calendar.HOUR_OF_DAY);        cMin=calRemClose.get(Calendar.MINUTE);        cHrStr=Integer.toString(cHr);        cMinStr=Integer.toString(cMin);        if (cMinStr.length() == 1) patch=":0";        else patch=":";        cTimeStr=cHrStr + patch + cMinStr;        if (dayYrOutClose != newDayOfYr) { // did change in time zone create a day change for closing calendar          if (dayYrOutClose > newDayOfYr) {            hDay=-1;            cArrow=">";          }          else {            hDay=1;            cArrow="<";          }          calUtil.set(yr, mth, newDayOfMth + hDay, hrCloses, minCloses, 0);          calUtil.getTimeInMillis(); // force calendar calculations          holidayClose=hldRem.isHoliday(calUtil);          if (!holidayClose) { // if not a holiday at remote exchange reset calendar            calRemClose.clear();            calRemClose.set(yr, mth, newDayOfMth, cHr, cMin, 0);          }        }        remCloseTime=calRemClose.getTimeInMillis();        oldDayOfYr=newDayOfYr; // set flag for day change      }      boolean localHld=hldCur.isHoliday(calCurBar);      // info("localHld " + localHld + " sHldCur " + sHldCur);      if (remOpenTime > prevBarTime && remOpenTime <= curBarTime && !holidayOpen && !localHld) {        if (path1Enabled) {          xtime=series.getStartTime(i);          addFigure(new MarketExFigures(xtime, shLett + oArrow + oTimeStr, path1, f, tcolor, get("OPEN"), showState,              showCall));        }      }      if (remCloseTime > prevBarTime && remCloseTime <= curBarTime && !holidayClose && !localHld) {        if (path2Enabled) {          xtime=series.getStartTime(i);          addFigure(new MarketExFigures(xtime, shLett + cArrow + cTimeStr, path2, f, tcolor, get("CLOSE"), showState,              showCall));        }      }    }  }  // NEW CLASS  // NEW CLASS  // NEW CLASS  private static class MarketEx  {    String name="";    String letters="";    String strTimeZone="";    TimeZone timeZone=null;    int hrOpen=0;    int minOpen=0;    int hrClose=0;    int minClose=0;    // Called from initialize, each instance stores record for a particular stock exchange    public MarketEx(String iname, String iletters, String timeZ, String iopen, String iclose)    {      name=iname;      letters=iletters;      strTimeZone=timeZ;      timeZone=TimeZone.getTimeZone(timeZ);      String hOpen=iopen.substring(0, iopen.indexOf(":"));      String mOpen=iopen.substring(iopen.indexOf(":") + 1);      String hClose=iclose.substring(0, iclose.indexOf(":"));      String mClose=iclose.substring(iclose.indexOf(":") + 1);      hrOpen=Integer.parseInt(hOpen);      minOpen=Integer.parseInt(mOpen);      hrClose=Integer.parseInt(hClose);      minClose=Integer.parseInt(mClose);    }    @Override    public String toString()    {      return letters + " " + name + " " + strTimeZone;    }  }  private static class MarketExFigures extends Figure  {    long time=0;    Line2D line=null;    PathInfo path=null;    Text topLbl=null;    Text bottomLbl=null;    boolean showState=false;    boolean showCall=false;    // Called from addFigure(Figure f)    MarketExFigures(long itime, String icallLetters, PathInfo ipath, Font ifont, Color tcolor, String istate,        boolean ishowState, boolean ishowCall)    {      time=itime;      path=ipath;      showState=ishowState;      showCall=ishowCall;      topLbl=new Text(istate, ifont, new Insets(0, 0, 0, 0), true);      bottomLbl=new Text(icallLetters, ifont, new Insets(0, 0, 0, 0), true);      topLbl.setTextColor(tcolor);      bottomLbl.setTextColor(tcolor);    }    @Override    // Called from addFigure    public boolean isVisible(DrawContext ctx)    {      DataSeries series=ctx.getDataContext().getDataSeries();      if (series.isLatestData()) return true;      long startT=series.getVisibleStartTime();      long endT=series.getVisibleEndTime();      return (time >= startT && time <= endT);    }    @Override    //used to make lines respond to mouse click     public boolean contains(double x, double y, DrawContext ctx)    {      if (!isVisible(ctx)) return false;      if (line == null) return false;      if (Util.distanceFromLine(x, y, line) < 6) return true;            return false;    }    @Override    // Called from addFigure    public synchronized void layout(DrawContext ctx)    {      Point2D p=ctx.translate(time, 0);      Rectangle bounds=ctx.getBounds();      if (p.getX() > bounds.getMaxX()) {        line=null;        return;      }      line=new Line2D.Double(p.getX(), bounds.y, p.getX(), bounds.getMaxY());      topLbl.setLocation(p.getX(), bounds.getY() + 2);      bottomLbl.setLocation(p.getX(), bounds.getMaxY() - bottomLbl.getHeight() - 2);    }    @Override    // Called from addFigure    public void draw(Graphics2D gc, DrawContext ctx)    {      Rectangle bounds=ctx.getBounds();      if (line == null || line.getX1() > bounds.getMaxX()) return;      gc.setStroke(path.getStroke());      gc.setColor(path.getColor());      gc.draw(line);      if (showState) topLbl.draw(gc);      if (showCall) bottomLbl.draw(gc);    } // draw  } // MarketExFigures  private static class Holidays  {    String name="";    int yr=2012;    int mth=1;    int dayOfWk=1;    int dayOfMth=0;    int wkOfMth=0;    GregorianCalendar cal=new GregorianCalendar(); // Utility Calendar    // constructor iname is timezone string    public Holidays(String iname)    {      name=iname;    }    // Check for holidays in some time zones or default    public boolean isHoliday(GregorianCalendar idate)    {      dayOfWk=idate.get(Calendar.DAY_OF_WEEK);      dayOfMth=idate.get(Calendar.DAY_OF_MONTH);      mth=idate.get(Calendar.MONTH);      wkOfMth=idate.get(Calendar.WEEK_OF_MONTH);      yr=idate.get(Calendar.YEAR);      if (name.equals("America/New_York")) { return defaults() || martinLutherKing() || presidentsDay()          || (goodFriday()) || (memorialDay()) || independanceDay() || (laborDay()) || (thanksGivingUS()); }      if (name.equals("America/Chicago")) { return defaults() || martinLutherKing() || presidentsDay()          || (goodFriday()) || (memorialDay()) || independanceDay() || (laborDay()) || (thanksGivingUS()); }      if (name.equals("America/Toronto")) { return defaults() || canadaDay() || familyDay() || (goodFriday())          || victoriaDay() || civicDay() || laborDay() || thanksGivingCND() || boxingDay(); }      if (name.equals("Europe/London")) { return defaults() || earlyMay() || goodFriday() || easterMonday() || spring()          || queenDJ() || summer() || boxingDay(); }      if (name.equals("Asia/Hong_Kong")) { return defaults() || lunarNewYears() || goodFriday() || easterMonday()          || laborDayParis() || sarEstablishmentDay() || chineseNationalDay() || (boxingDay()); }      if (name.equals("Pacific/Auckland")) { return defaults() || dayAfterNewYears() || waitangiDay() || goodFriday()          || easterMonday() || anzacDay() || queensBirthday() || laborDayNZ() || (boxingDay()); }      if (name.equals("Europe/Paris")) { return defaults() || laborDayParis() || goodFriday() || easterMonday()          || boxingDay(); }      if (name.equals("Europe/Berlin")) { return defaults() || laborDayParis() || goodFriday() || easterMonday()          || boxingDay() || christmasEve() || newYearsEve(); }      if (name.equals("Australia/Sydney")) { return defaults() || australiaDay() || goodFriday() || easterMonday()          || anzacDay() || queensBirthday() || boxingDay(); }      if (name.equals("America/Mexico_City")) { return defaults() || constitutionDay() || juarezDay() || holyThursday()          || laborDayMex() || allSoulsDay() || mexicanRevolution() || ladyGuadalupe(); }      if (name.equals("Japan")) { return defaults() || bankHoliday() || adultsDay() || vernalEquinox() || showa()          || constitutionJapan() || greeneryDay() || marineDay() || agedDay() || laborThanksgivingDay() || cultureDay()          || healthSportsDay() || emperorsBday() || newYearsEve(); }      if (name.equals("Europe/Rome")) { return defaults() || laborDayParis() || assuptionDay() || goodFriday()          || easterMonday() || christmasEve() || newYearsEve(); }      if (name.equals("Asia/Kolkata")) { return defaults() || republicDay() || mahashivratriDay() || holiDay()          || mahavirDays() || goodFriday() || mayDay() || independanceDayIndia() || ramzanId() || ganeshChaturhi()          || mahatmaGandhiBday() || dasara() || bakriId() || diwali() || bhaubee() || guruNanakJayanti()          || christmasEve() || newYearsEve(); }      return defaults();    }    // defaults    private boolean defaults()    {      return weekend() || newYears() || christmas();    }    private boolean weekend()    {      boolean ret=(dayOfWk == Calendar.SUNDAY || dayOfWk == Calendar.SATURDAY);      // if (ret) holiday = "Weekend";      return ret;    }    private boolean newYears()    {      boolean ret=(mth == Calendar.JANUARY && dayOfMth == 2 && dayOfWk == Calendar.MONDAY) || // January 1 == Sunday          (mth == Calendar.DECEMBER && dayOfMth == 31 && dayOfWk == Calendar.FRIDAY) || // January 1 == Saturday          (mth == Calendar.JANUARY && dayOfMth == 1);      // if (ret) holiday = "NewYears";      return ret;    }    private boolean christmas()    {      boolean ret=(mth == Calendar.DECEMBER && dayOfMth == 24 && dayOfWk == Calendar.FRIDAY) || // December 25 ==                                                                                                // Saturday          (mth == Calendar.JANUARY && dayOfMth == 26 && dayOfWk == Calendar.MONDAY) || // December 25 == Sunday          (mth == Calendar.DECEMBER && dayOfMth == 25);      // if (ret) holiday = "Christmas";      return ret;    }    // New Zealand    private boolean dayAfterNewYears()    {      boolean ret=(mth == Calendar.JANUARY && dayOfMth == 2);      // if (ret) holiday = "DayAfterNY";      return ret;    }    // Frankfurt    private boolean newYearsEve()    {      boolean ret=(mth == Calendar.DECEMBER && dayOfMth == 31);      // if (ret) holiday = "NewYearsEve";      return ret;    }    private boolean christmasEve()    {      boolean ret=(mth == Calendar.DECEMBER && dayOfMth == 24);      // if (ret) holiday = "ChristmasEve";      return ret;    }    // no calculation for this holiday    private boolean goodFriday()    {      // info("goodFriday");      boolean ret=(yr == 2011 && mth == Calendar.APRIL && dayOfMth == 22)          || (yr == 2012 && mth == Calendar.APRIL && dayOfMth == 6)          || (yr == 2013 && mth == Calendar.MARCH && dayOfMth == 29)          || (yr == 2014 && mth == Calendar.APRIL && dayOfMth == 18)          || (yr == 2015 && mth == Calendar.APRIL && dayOfMth == 3)          || (yr == 2016 && mth == Calendar.MARCH && dayOfMth == 25);      // if (ret) holiday = "GoodFriday";      return ret;    }    // no calculation for this holiday-follows good Friday by 3 days    private boolean easterMonday()    {      // info("easterMonday");      boolean ret=(yr == 2011 && mth == Calendar.APRIL && dayOfMth == 25)          || (yr == 2012 && mth == Calendar.APRIL && dayOfMth == 9)          || (yr == 2013 && mth == Calendar.APRIL && dayOfMth == 1)          || (yr == 2014 && mth == Calendar.APRIL && dayOfMth == 21)          || (yr == 2015 && mth == Calendar.APRIL && dayOfMth == 6)          || (yr == 2016 && mth == Calendar.MARCH && dayOfMth == 28);      // if (ret) holiday = "EasterMonday";      return ret;    }    // English no calculation    private boolean spring()    {      boolean ret=(yr == 2012 && mth == Calendar.JUNE && dayOfMth == 4)          || (yr == 2013 && mth == Calendar.MAY && dayOfMth == 27)          || (yr == 2014 && mth == Calendar.MAY && dayOfMth == 5)          || (yr == 2015 && mth == Calendar.MAY && dayOfMth == 4);      // if (ret) holiday = "Spring";      return ret;    }    // English no calculation    private boolean summer()    {      boolean ret=(yr == 2012 && mth == Calendar.AUGUST && dayOfMth == 27)          || (yr == 2013 && mth == Calendar.AUGUST && dayOfMth == 26)          || (yr == 2014 && mth == Calendar.AUGUST && dayOfMth == 25)          || (yr == 2015 && mth == Calendar.AUGUST && dayOfMth == 31);      // if (ret) holiday = "Summer";      return ret;    }    // English no calculation one time event    private boolean queenDJ()    {      boolean ret=(yr == 2012 && mth == Calendar.JUNE && dayOfMth == 5);      // if (ret) holiday = "QueenDJ";      return ret;    }    // US    private boolean martinLutherKing()    {      boolean ret=(mth == Calendar.JANUARY && wkOfMth == 3 && dayOfWk == Calendar.MONDAY); // Martin Luther King Day      // if (ret) holiday = "MartinLutherKing";      return ret;    }    // US    private boolean presidentsDay()    {      boolean ret=(mth == Calendar.FEBRUARY && wkOfMth == 3 && dayOfWk == Calendar.MONDAY); // Presidents Day      // if (ret) holiday = "PresidentsDay";      return ret;    }    // US    private boolean memorialDay()    {      int memDay=0;      cal.clear();      cal.set(yr, Calendar.MAY, 31);      for (int i=31; i > 23; i--) { // Memorial day == last Monday in May        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        int iday=cal.get(Calendar.DAY_OF_WEEK);        if (iday == Calendar.MONDAY) {          memDay=i;          break;        }      }      boolean ret=(mth == Calendar.MAY && dayOfMth == memDay);      // if (ret) holiday = "MemorialDay";      return ret;    }    // US    private boolean independanceDay()    {      boolean ret=(mth == Calendar.JULY && dayOfMth == 4) || // Independence Day          (mth == Calendar.JULY && dayOfMth == 5 && dayOfWk == Calendar.MONDAY) || // Independence Day == Sunday          (mth == Calendar.JULY && dayOfMth == 3 && dayOfWk == Calendar.FRIDAY); // Independence Day == Saturday      // if (ret) holiday = "IndependanceDay";      return ret;    }    // US    private boolean thanksGivingUS()    {      int count=0, tgDay=0;      cal.clear();      cal.set(yr, Calendar.NOVEMBER, 1);      for (int i=1; i < 31; i++) { // Thanksgiving == 4th Thursday in November        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        int day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.THURSDAY) {          count++;          if (count == 4) {            tgDay=i;            break;          }        }      }      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == tgDay); // Thanksgiving Day US version      // if (ret) holiday = "ThanksGivingDay";      return ret;    }    // US, Canada    private boolean laborDay()    {      int laborDay=0;      cal.clear();      cal.set(yr, Calendar.SEPTEMBER, 1);      for (int i=1; i > 8; i++) { // Labour day == first Monday in September        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        laborDay=cal.get(Calendar.DAY_OF_WEEK);        if (laborDay == Calendar.MONDAY) {          laborDay=i;          break;        }      }      boolean ret=(mth == Calendar.SEPTEMBER && dayOfMth == laborDay); // Labor Day US      // if (ret) holiday = "LaborDay";      return ret;    }    // Canadian    private boolean canadaDay()    {      boolean ret=(mth == Calendar.JULY && dayOfMth == 1) || // Canada Day          (mth == Calendar.JULY && dayOfMth == 2 && dayOfWk == Calendar.MONDAY) || // Canada Day == Sunday          (mth == Calendar.JUNE && dayOfMth == 30 && dayOfWk == Calendar.FRIDAY); // Canada Day == Saturday      // if (ret) holiday = "CanadaDay";      return ret;    }    // Canada    private boolean familyDay()    {      int famDay=0, count=0;      cal.clear();      cal.set(yr, Calendar.FEBRUARY, 1);      for (int i=1; i < 15; i++) { // Family day == 2nd Monday in February        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        famDay=cal.get(Calendar.DAY_OF_WEEK);        if (famDay == Calendar.MONDAY) {          count++;          if (count == 2) {            famDay=i;            break;          }        }      }      boolean ret=(mth == Calendar.FEBRUARY && dayOfMth == famDay); // Family Day      // if (ret) holiday = "FamilyDay";      return ret;    }    // Canada    private boolean thanksGivingCND()    {      int count=0, tgDay=0;      cal.clear();      cal.set(yr, Calendar.OCTOBER, 1);      count=0;      for (int i=1; i < 15; i++) { // Thanksgiving == 2th Monday in October        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        int day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 2) {            tgDay=i;            break;          }        }      }      boolean ret=(mth == Calendar.OCTOBER && dayOfMth == tgDay); // Thanksgiving Day Canadian version      // if (ret) holiday = "ThanksGivingC";      return ret;    }    // Canada, English,Frankfurt    private boolean boxingDay()    {      // info("boxing");      boolean ret=(mth == Calendar.DECEMBER && dayOfMth == 27 && dayOfWk == Calendar.MONDAY) || // Boxing Day == Sunday          (mth == Calendar.DECEMBER && dayOfMth == 28 && dayOfWk == Calendar.MONDAY) || // Boxing Day == Saturday          (mth == Calendar.DECEMBER && dayOfMth == 26); // Boxing Day      // if (ret) holiday = "BoxingDay";      return ret;    }    // Canada    private boolean victoriaDay()    {      int vicDay=0;      cal.clear();      cal.set(yr, Calendar.MAY, 25);      for (int i=24; i > 17; i--) { // Victoria day == Monday before May 25        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        vicDay=cal.get(Calendar.DAY_OF_WEEK);        if (vicDay == Calendar.MONDAY) {          vicDay=i;          break;        }      }      boolean ret=(mth == Calendar.MAY && dayOfMth == vicDay); // Victoria Day      // if (ret) holiday = "VictoriaDay";      return ret;    }    // Canada    private boolean civicDay()    {      int civicDay=0;      cal.clear();      cal.set(yr, Calendar.AUGUST, 1);      for (int i=1; i > 8; i++) { // Civic day == first Monday in August        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        civicDay=cal.get(Calendar.DAY_OF_WEEK);        if (civicDay == Calendar.MONDAY) {          civicDay=i;          break;        }      }      boolean ret=(mth == Calendar.AUGUST && dayOfMth == civicDay); // Civic Day      // if (ret) holiday = "CivicDay";      return ret;    }    // English    private boolean earlyMay()    {      int erlyMay=0;      cal.clear();      cal.set(yr, Calendar.MAY, 1);      for (int i=1; i < 8; i++) { // Early May == 1nd Monday in MAY        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        erlyMay=cal.get(Calendar.DAY_OF_WEEK);        if (erlyMay == Calendar.MONDAY) {          erlyMay=i;          break;        }      }      boolean ret=(mth == Calendar.MAY && dayOfMth == erlyMay); // Early May      // if (ret) holiday = "EarlyMay";      return ret;    }    // Hong Kong    private boolean lunarNewYears()    {      boolean ret=(yr == 2012 && mth == Calendar.JANUARY && (dayOfMth == 23 || dayOfMth == 24 || dayOfMth == 25))          || (yr == 2013 && mth == Calendar.JANUARY && (dayOfMth == 11) || (dayOfMth == 12) || (dayOfMth == 13))          || (yr == 2014 && mth == Calendar.JANUARY && dayOfMth == 31)          || (yr == 2014 && mth == Calendar.FEBRUARY && dayOfMth == 3);      // if (ret) holiday = "Lunar";      return ret;    }    // Paris,Hong Kong,Frankfurt    private boolean laborDayParis()    {      boolean ret=(mth == Calendar.MAY && dayOfMth == 1);      // if (ret) holiday = "LaborDayEurope";      return ret;    }    // Hong Kong    private boolean sarEstablishmentDay()    {      boolean ret=(yr == 2012 && mth == Calendar.JULY && dayOfMth == 2)          || (yr == 2013 && mth == Calendar.JULY && dayOfMth == 1)          || (yr == 2014 && mth == Calendar.JULY && dayOfMth == 1);      // if (ret) holiday = "SarED";      return ret;    }    // Hong Kong    private boolean chineseNationalDay()    {      boolean ret=(yr == 2012 && mth == Calendar.OCTOBER && dayOfMth == 1)          || (yr == 2013 && mth == Calendar.OCTOBER && dayOfMth == 1)          || (yr == 2014 && mth == Calendar.OCTOBER && dayOfMth == 1);      // if (ret) holiday = "NationalDay";      return ret;    }    // Australia    private boolean australiaDay()    {      // info("anzacDay");      boolean ret=(mth == Calendar.JANUARY && dayOfMth == 27 && dayOfWk == Calendar.MONDAY) || // January 26 == Sunday          (mth == Calendar.JANUARY && dayOfMth == 25 && dayOfWk == Calendar.FRIDAY) || // January 26 == Saturday          (mth == Calendar.JANUARY && dayOfMth == 26); // Australia day      // if (ret) holiday = "AustraliaDay";      return ret;    }    // New Zealand    private boolean waitangiDay()    {      // info("waitangi");      boolean ret=(mth == Calendar.FEBRUARY && dayOfMth == 6);      // if (ret) holiday = "Waitangi";      return ret;    }    // New Zealand    private boolean anzacDay()    {      // info("anzacDay");      boolean ret=(mth == Calendar.APRIL && dayOfMth == 25);      // if (ret) holiday = "AnzacDay";      return ret;    }    // Australia,New Zealand    private boolean queensBirthday()    {      // info("queensBith");      int queen=0;      cal.clear();      cal.set(yr, Calendar.JUNE, 1);      for (int i=1; i < 8; i++) { // queen == 1nd Monday in JUNE        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        queen=cal.get(Calendar.DAY_OF_WEEK);        if (queen == Calendar.MONDAY) {          queen=i;          break;        }      }      boolean ret=(mth == Calendar.JUNE && dayOfMth == queen); // Early May      // if (ret) holiday = "QueensBirthday";      return ret;    }    // New Zealand    private boolean laborDayNZ()    {      // info("laborDayNZ");      int day=0, count=0, lbDay=0;      cal.clear();      cal.set(yr, Calendar.OCTOBER, 1);      for (int i=1; i < 32; i++) { // labor day == 4th Monday in October        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 4) {            lbDay=i;            break;          }        }      }      boolean ret=(mth == Calendar.OCTOBER && dayOfMth == lbDay);      // if (ret) holiday = "LaborDayNZ";      return ret;    }    // Mexico    private boolean constitutionDay()    {      int cont=0;      cal.clear();      cal.set(yr, Calendar.FEBRUARY, 1);      for (int i=1; i < 8; i++) { // Constitution Day == 1nd Monday in FEB        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        cont=cal.get(Calendar.DAY_OF_WEEK);        if (cont == Calendar.MONDAY) {          cont=i;          break;        }      }      boolean ret=(mth == Calendar.FEBRUARY && dayOfMth == cont);      // if (ret) holiday = "ConstitutionDay";      return ret;    }    // Mexico    private boolean juarezDay()    {      int count=0, jDay=0;      cal.clear();      cal.set(yr, Calendar.MARCH, 1);      count=0;      for (int i=1; i < 31; i++) { // JuarezDay == 3th Monday in MARCH        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        int day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 4) {            jDay=i;            break;          }        }      }      boolean ret=(mth == Calendar.MARCH && dayOfMth == jDay); // Thanksgiving Day Canadian version      // if (ret) holiday = "JuarezDay";      return ret;    }    // Mexico    private boolean holyThursday()    {      int day=0;      cal.clear();      cal.set(yr, Calendar.APRIL, 1);      for (int i=1; i < 8; i++) { // Holy Thursday == 1nd Thursday in April        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.THURSDAY) {          day=i;          break;        }      }      boolean ret=(mth == Calendar.APRIL && dayOfMth == day);      // if (ret) holiday = "HolyThursday";      return ret;    }    // Mexico    private boolean laborDayMex()    {      boolean ret=(mth == Calendar.JUNE && dayOfMth == 1);      // if (ret) holiday = "LaborDayMex";      return ret;    }    // Mexico    private boolean allSoulsDay()    {      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == 2);      // if (ret) holiday = "LaborDayMex";      return ret;    }    // Mexico    private boolean mexicanRevolution()    {      int count=0, day=0;      cal.clear();      cal.set(yr, Calendar.NOVEMBER, 1);      count=0;      for (int i=1; i < 31; i++) { // Mexican Revolution == 3th Monday in November        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 3) {            day=i;            break;          }        }      }      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == day);      // if (ret) holiday = "MexicanRevolution";      return ret;    }    // New Zealand    private boolean ladyGuadalupe()    {      // info(" ladyGuadalupe");      boolean ret=(mth == Calendar.DECEMBER && dayOfMth == 12);      // if (ret) holiday = "LadyGuadalupe";      return ret;    }    // Japan    private boolean bankHoliday()    {      // info("bankHoliday");      boolean ret=(mth == Calendar.JANUARY && (dayOfMth == 1 || dayOfMth == 2 || dayOfMth == 3));      // if (ret) holiday = "BankHoliday";      return ret;    }    // Japan    private boolean adultsDay()    {      int count=0, day=0;      cal.clear();      cal.set(yr, Calendar.JANUARY, 1);      count=0;      for (int i=1; i < 31; i++) { // comming of age/adults day == 3th Monday in January        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 3) {            day=i;            break;          }        }      }      boolean ret=(mth == Calendar.JANUARY && dayOfMth == day);      // if (ret) holiday = "AdultsDay";      return ret;    }    // Japan    private boolean vernalEquinox()    {      boolean ret=(mth == Calendar.MARCH && dayOfMth == 20);      // if (ret) holiday = "VernalEquinox";      return ret;    }    // Japan    private boolean showa()    {      boolean ret=(yr == 2012 && mth == Calendar.APRIL && dayOfMth == 30)          || (yr == 2013 && mth == Calendar.APRIL && dayOfMth == 29)          || (yr == 2014 && mth == Calendar.APRIL && dayOfMth == 29)          || (yr == 2015 && mth == Calendar.MAY && dayOfMth == 4)          || (yr == 2016 && mth == Calendar.MAY && dayOfMth == 4);      // if (ret) holiday = "Showa";      return ret;    }    // Japan    private boolean constitutionJapan()    {      boolean ret=(yr == 2012 && mth == Calendar.MAY && dayOfMth == 3)          || (yr == 2013 && mth == Calendar.MAY && dayOfMth == 3)          || (yr == 2015 && mth == Calendar.MAY && dayOfMth == 6)          || (yr == 2016 && mth == Calendar.MAY && dayOfMth == 3);      // if (ret) holiday = "ConstitutionJapan";      return ret;    }    // Japan    private boolean greeneryDay()    {      boolean ret=(mth == Calendar.JUNE && dayOfMth == 4);      // if (ret) holiday = "GreeneryDay";      return ret;    }    // Japan    private boolean marineDay()    {      int count=0, day=0;      cal.clear();      cal.set(yr, Calendar.JULY, 1);      count=0;      for (int i=1; i < 31; i++) { // marine day == 3th Monday in July        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 3) {            day=i;            break;          }        }      }      boolean ret=(mth == Calendar.JULY && dayOfMth == day);      // if (ret) holiday = "MarineDay";      return ret;    }    // Japan    private boolean agedDay()    {      int count=0, day=0;      cal.clear();      cal.set(yr, Calendar.SEPTEMBER, 1);      count=0;      for (int i=1; i < 31; i++) { // 3th Monday in September        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 3) {            day=i;            break;          }        }      }      boolean ret=(mth == Calendar.SEPTEMBER && dayOfMth == day);      // if (ret) holiday = "RespectForTheAgedDay";      return ret;    }    // Japan    private boolean healthSportsDay()    {      int count=0, day=0;      cal.clear();      cal.set(yr, Calendar.OCTOBER, 1);      count=0;      for (int i=1; i < 31; i++) { // 2th Monday in October        cal.set(Calendar.DAY_OF_MONTH, i);        cal.getTimeInMillis(); // force calendar calculations        day=cal.get(Calendar.DAY_OF_WEEK);        if (day == Calendar.MONDAY) {          count++;          if (count == 2) {            day=i;            break;          }        }      }      boolean ret=(mth == Calendar.OCTOBER && dayOfMth == day);      // if (ret) holiday = "HealthSportsDay";      return ret;    }    // Japan    private boolean cultureDay()    {      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == 3);      // if (ret) holiday = "CultureDay";      return ret;    }    // Japan    private boolean laborThanksgivingDay()    {      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == 23);      // if (ret) holiday = "LaborThanksgivingDay";      return ret;    }    // Japan    private boolean emperorsBday()    {      boolean ret=(mth == Calendar.DECEMBER && dayOfMth == 24 && dayOfWk == Calendar.MONDAY) || // Dec 23 == Sunday          (mth == Calendar.DECEMBER && dayOfMth == 22 && dayOfWk == Calendar.FRIDAY) || // Dec 23 == Saturday          (mth == Calendar.DECEMBER && dayOfMth == 23);      // if (ret) holiday = "EmporersBirthday";      return ret;    }    // Italy    private boolean assuptionDay()    {      boolean ret=(mth == Calendar.AUGUST && dayOfMth == 15);      // if (ret) holiday = "AssuptionDay";      return ret;    }    // India    private boolean republicDay()    {      boolean ret=(mth == Calendar.JANUARY && dayOfMth == 26);      // if (ret) holiday = "RepublicDay";      return ret;    }    // India    private boolean mahashivratriDay()    {      boolean ret=(mth == Calendar.FEBRUARY && dayOfMth == 20);      // if (ret) holiday = "MahashivratriDay";      return ret;    }    // India    private boolean mahavirDays()    {      boolean ret=(mth == Calendar.APRIL && dayOfMth == 4) || (mth == Calendar.APRIL && dayOfMth == 5);      // if (ret) holiday = "MahavirDays";      return ret;    }    // India    private boolean holiDay()    {      boolean ret=(mth == Calendar.MARCH && dayOfMth == 8);      // if (ret) holiday = "HoliDay";      return ret;    }    // India    private boolean mayDay()    {      boolean ret=(mth == Calendar.MAY && dayOfMth == 1);      // if (ret) holiday = "MayDay";      return ret;    }    // India    private boolean independanceDayIndia()    {      boolean ret=(mth == Calendar.AUGUST && dayOfMth == 15);      // if (ret) holiday = "IndependanceDayIndia";      return ret;    }    // India    private boolean ramzanId()    {      boolean ret=(mth == Calendar.AUGUST && dayOfMth == 20);      // if (ret) holiday = "RamzanId";      return ret;    }    private boolean ganeshChaturhi()    {      boolean ret=(mth == Calendar.SEPTEMBER && dayOfMth == 19);      // if (ret) holiday = "GaneshChaturhi";      return ret;    }    private boolean mahatmaGandhiBday()    {      boolean ret=(mth == Calendar.OCTOBER && dayOfMth == 2);      // if (ret) holiday = "MahatmaGandhiBday";      return ret;    }    private boolean dasara()    {      boolean ret=(mth == Calendar.OCTOBER && dayOfMth == 24);      // if (ret) holiday = "Dasara";      return ret;    }    private boolean bakriId()    {      boolean ret=(mth == Calendar.OCTOBER && dayOfMth == 26);      // if (ret) holiday = "BakriId";      return ret;    }    private boolean diwali()    {      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == 14);      // if (ret) holiday = "Diwali";      return ret;    }    private boolean bhaubee()    {      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == 16);      // if (ret) holiday = "Bhaubee";      return ret;    }    private boolean guruNanakJayanti()    {      boolean ret=(mth == Calendar.NOVEMBER && dayOfMth == 28);      // if (ret) holiday = "GuruNanakJayanti";      return ret;    }  } // Holidays class bracket} // MarketExchanges final bracket