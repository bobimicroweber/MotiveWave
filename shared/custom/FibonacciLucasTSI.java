package com.motivewave.platform.study.custom;import java.awt.Color;import java.awt.Font;import java.util.Calendar;import java.util.GregorianCalendar;import com.motivewave.platform.sdk.common.Coordinate;import com.motivewave.platform.sdk.common.DataContext;import com.motivewave.platform.sdk.common.DataSeries;import com.motivewave.platform.sdk.common.Defaults;import com.motivewave.platform.sdk.common.Enums;import com.motivewave.platform.sdk.common.FontInfo;import com.motivewave.platform.sdk.common.Inputs;import com.motivewave.platform.sdk.common.MarkerInfo;import com.motivewave.platform.sdk.common.Util;import com.motivewave.platform.sdk.common.desc.BooleanDescriptor;import com.motivewave.platform.sdk.common.desc.ColorDescriptor;import com.motivewave.platform.sdk.common.desc.FontDescriptor;import com.motivewave.platform.sdk.common.desc.IndicatorDescriptor;import com.motivewave.platform.sdk.common.desc.InputDescriptor;import com.motivewave.platform.sdk.common.desc.IntegerDescriptor;import com.motivewave.platform.sdk.common.desc.MAMethodDescriptor;import com.motivewave.platform.sdk.common.desc.MarkerDescriptor;import com.motivewave.platform.sdk.common.desc.PathDescriptor;import com.motivewave.platform.sdk.common.desc.ValueDescriptor;import com.motivewave.platform.sdk.draw.Label;import com.motivewave.platform.sdk.draw.Marker;import com.motivewave.platform.sdk.study.Study;import com.motivewave.platform.sdk.study.StudyHeader;import com.motivewave.platform.study.general.Utility;/** Fibonacci Lucas Time Series Indicator 180 */@StudyHeader(  namespace="com.motivewave",  id="ID_FIB_LUC_TSI",  rb="com.motivewave.platform.study.nls.strings2",  name="NAME_FIBONACCI_LUCAS_TIME_SERIES_INDICATOR",  label="LBL_FLTSI",  desc="DESC_FLTSI",  // menu="MENU_CUSTOM",  helpLink="http://www.motivewave.com/studies/fibonacci_lucas_time_series_indicator.htm",  signals=true,  overlay=true,  requiresVolume=false,  studyOverlay=true)public class FibonacciLucasTSI extends Study{  final static String YEAR="Year", MONTH="Month", DAY="Day", HOUR="Hour", MINUTE="Minute";  final static String FIBONACCI="Fibonacci", LUCAS="Lucas", NEUTRAL="Neutral", ENTERS="Enters", EXITS="Exits", NEUTRAL_ON="NeutralOn";  protected enum Signals { ENTER, EXIT }  enum Values { MA, INDX }  private int startIndex=-1;  @Override  public void initialize(Defaults defaults)  {    var sd=createSD();    var tab=sd.addTab(get("TAB_GENERAL"));    var inputs=tab.addGroup(get("INPUTS"));    inputs.addRow(new IntegerDescriptor(YEAR, get("STARTING_YEAR"), 2012, 1980, 2100, 1));    inputs.addRow(new IntegerDescriptor(MONTH, get("STARTING_MONTH"), 9, 1, 12, 1));    inputs.addRow(new IntegerDescriptor(DAY, get("STARTING_DAY"), 10, 1, 31, 1));    inputs.addRow(new IntegerDescriptor(HOUR, get("STARTING_HOUR"), 10, 0, 24, 1));    inputs.addRow(new IntegerDescriptor(MINUTE, get("STARTING_MINUTE"), 0, 0, 60, 1));    inputs.addRow(new InputDescriptor(Inputs.INPUT, get("INPUT"), Enums.BarInput.CLOSE));    inputs.addRow(new MAMethodDescriptor(Inputs.METHOD, get("METHOD"), Enums.MAMethod.EMA));    inputs.addRow(new IntegerDescriptor(Inputs.PERIOD, get("PERIOD"), 21, 1, 9999, 1));    inputs.addRow(new BooleanDescriptor(NEUTRAL_ON, get("NEUTRAL_COLOR_ON"), true));    inputs.addRow(new FontDescriptor(Inputs.FONT, get("FONT"), defaults.getFont()));    tab=sd.addTab(get("TAB_DISPLAY"));    var settings=tab.addGroup(get("PATH_INDICATOR"));    settings.addRow(new PathDescriptor(Inputs.PATH, get("PATH"), defaults.getLineColor(), 1.0f, null, true, false, true));    settings.addRow(new IndicatorDescriptor(Inputs.IND, get("IND"), defaults.getLineColor(), null, false, true, true));    settings=tab.addGroup(get("BAR_COLORS"));    settings.addRow(new ColorDescriptor(FIBONACCI, get("FIBONACCI"), defaults.getBlue()));    settings.addRow(new ColorDescriptor(LUCAS, get("LUCAS"), defaults.getYellow()));    settings.addRow(new ColorDescriptor(NEUTRAL, get("NEUTRAL_BAR"), defaults.getGrey()));    settings.addRow(new ColorDescriptor(ENTERS, get("ENTER_MESSAGE"), defaults.getGreen()));    settings.addRow(new ColorDescriptor(EXITS, get("EXIT_MESSAGE"), defaults.getBlue()));    var markers=tab.addGroup(get("MARKERS"));    markers.addRow(new MarkerDescriptor(Inputs.UP_MARKER, get("UP_MARKER"), Enums.MarkerType.TRIANGLE,        Enums.Size.VERY_SMALL, defaults.getGreen(), defaults.getLineColor(), true, true));    markers.addRow(new MarkerDescriptor(Inputs.DOWN_MARKER, get("DOWN_MARKER"), Enums.MarkerType.TRIANGLE,        Enums.Size.VERY_SMALL, defaults.getRed(), defaults.getLineColor(), true, true));    var desc=createRD();    desc.setLabelSettings(YEAR, MONTH, DAY, HOUR, MINUTE, Inputs.INPUT, Inputs.METHOD, Inputs.PERIOD);    desc.exportValue(new ValueDescriptor(Values.INDX, Enums.ValueType.INTEGER, get("INDEX"), null));    desc.exportValue(new ValueDescriptor(Values.MA, get("MA"), new String[] { Inputs.INPUT, Inputs.METHOD, Inputs.PERIOD }));    desc.exportValue(new ValueDescriptor(Signals.ENTER, Enums.ValueType.BOOLEAN, get("ENTER"), null));    desc.exportValue(new ValueDescriptor(Signals.EXIT, Enums.ValueType.BOOLEAN, get("EXIT"), null));    desc.declareSignal(Signals.ENTER, get("ENTER"));    desc.declareSignal(Signals.EXIT, get("EXIT"));    desc.declarePath(Values.MA, Inputs.PATH);    desc.declareIndicator(Values.MA, Inputs.IND);    desc.setRangeKeys(Values.MA);  }  @Override  public void onLoad(Defaults defaults)  {    startIndex=-1;    int p1=getSettings().getInteger(Inputs.PERIOD);    setMinBars(p1);  }  @Override  protected void calculate(int index, DataContext ctx)  {    int period=getSettings().getInteger(Inputs.PERIOD);    if (index < period) return;    int yr=getSettings().getInteger(YEAR);    int mth=getSettings().getInteger(MONTH);    int day=getSettings().getInteger(DAY);    int hr=getSettings().getInteger(HOUR);    int min=getSettings().getInteger(MINUTE);    Color fibC=getSettings().getColor(FIBONACCI);    Color lucC=getSettings().getColor(LUCAS);    Object input=getSettings().getInput(Inputs.INPUT, Enums.BarInput.CLOSE);    Enums.MAMethod method=getSettings().getMAMethod(Inputs.METHOD, Enums.MAMethod.EMA);    Color neutralC=getSettings().getColor(NEUTRAL);    Color enterC=getSettings().getColor(ENTERS);    Color exitC=getSettings().getColor(EXITS);    FontInfo fi=getSettings().getFont(Inputs.FONT);    Font f=fi.getFont();    boolean neutralOn=getSettings().getBoolean(NEUTRAL_ON);    DataSeries series=ctx.getDataSeries();    Defaults defaults=ctx.getDefaults();    long curBarTime=0;    String sigMess="", dispMess="", dateTime="";    boolean enter=false, exit=false;    int exitNo=0;    series.setInt(index, Values.INDX, index);    double price=series.getDouble(index, input, 0);    double high=series.getDouble(index, Enums.BarInput.HIGH, 0);    double low=series.getDouble(index, Enums.BarInput.LOW, 0);    Double ma=series.ma(method, index, period, input);    if (ma == null) return;    series.setDouble(index, Values.MA, ma);    GregorianCalendar cal=new GregorianCalendar();    curBarTime=series.getStartTime(index);    cal.setTimeInMillis(curBarTime);    int cYr=cal.get(Calendar.YEAR);    int cMth=cal.get(Calendar.MONTH);    int cDay=cal.get(Calendar.DAY_OF_MONTH);    int cHr=cal.get(Calendar.HOUR_OF_DAY);    int cMin=cal.get(Calendar.MINUTE);    if (cYr == yr && cMth == mth && cDay == day && cHr == hr && cMin == min) {      dateTime=String.valueOf(yr) + " " + String.valueOf(mth) + " " + String.valueOf(day) + " " + String.valueOf(hr)          + " " + String.valueOf(min);      startIndex=index;      sigMess=get("ENTER_PRICE_TIME");      dispMess=get("ENTER") + ":" + dateTime;      enter=true;    }    if (startIndex < 0) return;    if (neutralOn) series.setPriceBarColor(index, neutralC);    exitNo=index - startIndex;    if (Utility.isFibonacci(exitNo)) {      series.setPriceBarColor(index, fibC);      sigMess=get("EXIT_PRICE_FIBONACCI");      dispMess=get("EXIT_FIB") + String.valueOf(exitNo);      exit=true;    }    if (Utility.isLucas(exitNo)) {      series.setPriceBarColor(index, lucC);      sigMess=get("EXIT_PRICE_LUCAS");      dispMess=get("EXIT_LUC") + String.valueOf(exitNo);      exit=true;    }        boolean wasExit = series.getBoolean(index, Signals.EXIT, false) && index == series.size()-1;    boolean wasEnter = series.getBoolean(index, Signals.ENTER, false) && index == series.size()-1;        series.setBoolean(index, Signals.EXIT, exit);    series.setBoolean(index, Signals.ENTER, enter);    if (exit && !wasExit) {      Coordinate c=new Coordinate(series.getStartTime(index), high);      Label lbl=new Label(dispMess, f, defaults.getTextColor(), exitC);      lbl.setLocation(c);      addFigure(lbl);      MarkerInfo marker=getSettings().getMarker(Inputs.DOWN_MARKER);      String msg = get(sigMess, Util.round(price, 2), Util.round(exitNo, 3));      if (marker.isEnabled()) addFigure(new Marker(c, Enums.Position.TOP, marker, msg));      ctx.signal(index, Signals.EXIT, msg, price);    }    if (enter && !wasEnter) {      Coordinate c=new Coordinate(series.getStartTime(index), low);      Label lbl=new Label(dispMess, f, defaults.getTextColor(), enterC);      lbl.setLocation(c);      addFigure(lbl);      MarkerInfo marker=getSettings().getMarker(Inputs.UP_MARKER);      String msg = get(sigMess, Util.round(price, 2), dateTime);      if (marker.isEnabled()) addFigure(new Marker(c, Enums.Position.BOTTOM, marker, msg));      ctx.signal(index, Signals.ENTER, msg, price);    }    series.setComplete(index);  }}